// eslint-disable-next-line
export default "var __BUNDLE_START_TIME__=this.nativePerformanceNow?nativePerformanceNow():Date.now(),__DEV__=true,process=this.process||{},__METRO_GLOBAL_PREFIX__='',__requireCycleIgnorePatterns=[/(^|\\/|\\\\)node_modules($|\\/|\\\\)/];process.env=process.env||{};process.env.NODE_ENV=process.env.NODE_ENV||\"development\";\n(function (global) {\n  \"use strict\";\n\n  global.__r = metroRequire;\n  global[`${__METRO_GLOBAL_PREFIX__}__d`] = define;\n  global.__c = clear;\n  global.__registerSegment = registerSegment;\n  var modules = clear();\n  var EMPTY = {};\n  var CYCLE_DETECTED = {};\n  var _ref = {},\n    hasOwnProperty = _ref.hasOwnProperty;\n  if (__DEV__) {\n    global.$RefreshReg$ = function () {};\n    global.$RefreshSig$ = function () {\n      return function (type) {\n        return type;\n      };\n    };\n  }\n  function clear() {\n    modules = new Map();\n    return modules;\n  }\n  if (__DEV__) {\n    var verboseNamesToModuleIds = new Map();\n    var getModuleIdForVerboseName = function getModuleIdForVerboseName(verboseName) {\n      var moduleId = verboseNamesToModuleIds.get(verboseName);\n      if (moduleId == null) {\n        throw new Error(`Unknown named module: \"${verboseName}\"`);\n      }\n      return moduleId;\n    };\n    var initializingModuleIds = [];\n  }\n  function define(factory, moduleId, dependencyMap) {\n    if (modules.has(moduleId)) {\n      if (__DEV__) {\n        var inverseDependencies = arguments[4];\n        if (inverseDependencies) {\n          global.__accept(moduleId, factory, dependencyMap, inverseDependencies);\n        }\n      }\n      return;\n    }\n    var mod = {\n      dependencyMap: dependencyMap,\n      factory: factory,\n      hasError: false,\n      importedAll: EMPTY,\n      importedDefault: EMPTY,\n      isInitialized: false,\n      publicModule: {\n        exports: {}\n      }\n    };\n    modules.set(moduleId, mod);\n    if (__DEV__) {\n      mod.hot = createHotReloadingObject();\n      var verboseName = arguments[3];\n      if (verboseName) {\n        mod.verboseName = verboseName;\n        verboseNamesToModuleIds.set(verboseName, moduleId);\n      }\n    }\n  }\n  function metroRequire(moduleId) {\n    if (__DEV__ && typeof moduleId === \"string\") {\n      var verboseName = moduleId;\n      moduleId = getModuleIdForVerboseName(verboseName);\n      console.warn(`Requiring module \"${verboseName}\" by name is only supported for ` + \"debugging purposes and will BREAK IN PRODUCTION!\");\n    }\n    var moduleIdReallyIsNumber = moduleId;\n    if (__DEV__) {\n      var initializingIndex = initializingModuleIds.indexOf(moduleIdReallyIsNumber);\n      if (initializingIndex !== -1) {\n        var cycle = initializingModuleIds.slice(initializingIndex).map(function (id) {\n          var _modules$get$verboseN, _modules$get;\n          return (_modules$get$verboseN = (_modules$get = modules.get(id)) == null ? void 0 : _modules$get.verboseName) != null ? _modules$get$verboseN : \"[unknown]\";\n        });\n        if (shouldPrintRequireCycle(cycle)) {\n          cycle.push(cycle[0]);\n          console.warn(`Require cycle: ${cycle.join(\" -> \")}\\n\\n` + \"Require cycles are allowed, but can result in uninitialized values. \" + \"Consider refactoring to remove the need for a cycle.\");\n        }\n      }\n    }\n    var module = modules.get(moduleIdReallyIsNumber);\n    return module && module.isInitialized ? module.publicModule.exports : guardedLoadModule(moduleIdReallyIsNumber, module);\n  }\n  function shouldPrintRequireCycle(modules) {\n    var regExps = global[__METRO_GLOBAL_PREFIX__ + \"__requireCycleIgnorePatterns\"];\n    if (!Array.isArray(regExps)) {\n      return true;\n    }\n    var isIgnored = function isIgnored(module) {\n      return module != null && regExps.some(function (regExp) {\n        return regExp.test(module);\n      });\n    };\n    return modules.every(function (module) {\n      return !isIgnored(module);\n    });\n  }\n  function metroImportDefault(moduleId) {\n    if (__DEV__ && typeof moduleId === \"string\") {\n      var verboseName = moduleId;\n      moduleId = getModuleIdForVerboseName(verboseName);\n    }\n    var moduleIdReallyIsNumber = moduleId;\n    var maybeInitializedModule = modules.get(moduleIdReallyIsNumber);\n    if (maybeInitializedModule && maybeInitializedModule.importedDefault !== EMPTY) {\n      return maybeInitializedModule.importedDefault;\n    }\n    var exports = metroRequire(moduleIdReallyIsNumber);\n    var importedDefault = exports && exports.__esModule ? exports.default : exports;\n    var initializedModule = modules.get(moduleIdReallyIsNumber);\n    return initializedModule.importedDefault = importedDefault;\n  }\n  metroRequire.importDefault = metroImportDefault;\n  function metroImportAll(moduleId) {\n    if (__DEV__ && typeof moduleId === \"string\") {\n      var verboseName = moduleId;\n      moduleId = getModuleIdForVerboseName(verboseName);\n    }\n    var moduleIdReallyIsNumber = moduleId;\n    var maybeInitializedModule = modules.get(moduleIdReallyIsNumber);\n    if (maybeInitializedModule && maybeInitializedModule.importedAll !== EMPTY) {\n      return maybeInitializedModule.importedAll;\n    }\n    var exports = metroRequire(moduleIdReallyIsNumber);\n    var importedAll;\n    if (exports && exports.__esModule) {\n      importedAll = exports;\n    } else {\n      importedAll = {};\n      if (exports) {\n        for (var key in exports) {\n          if (hasOwnProperty.call(exports, key)) {\n            importedAll[key] = exports[key];\n          }\n        }\n      }\n      importedAll.default = exports;\n    }\n    var initializedModule = modules.get(moduleIdReallyIsNumber);\n    return initializedModule.importedAll = importedAll;\n  }\n  metroRequire.importAll = metroImportAll;\n  metroRequire.context = function fallbackRequireContext() {\n    if (__DEV__) {\n      throw new Error(\"The experimental Metro feature `require.context` is not enabled in your project.\\nThis can be enabled by setting the `transformer.unstable_allowRequireContext` property to `true` in your Metro configuration.\");\n    }\n    throw new Error(\"The experimental Metro feature `require.context` is not enabled in your project.\");\n  };\n  metroRequire.resolveWeak = function fallbackRequireResolveWeak() {\n    if (__DEV__) {\n      throw new Error(\"require.resolveWeak cannot be called dynamically. Ensure you are using the same version of `metro` and `metro-runtime`.\");\n    }\n    throw new Error(\"require.resolveWeak cannot be called dynamically.\");\n  };\n  var inGuard = false;\n  function guardedLoadModule(moduleId, module) {\n    if (!inGuard && global.ErrorUtils) {\n      inGuard = true;\n      var returnValue;\n      try {\n        returnValue = loadModuleImplementation(moduleId, module);\n      } catch (e) {\n        global.ErrorUtils.reportFatalError(e);\n      }\n      inGuard = false;\n      return returnValue;\n    } else {\n      return loadModuleImplementation(moduleId, module);\n    }\n  }\n  var ID_MASK_SHIFT = 16;\n  var LOCAL_ID_MASK = ~0 >>> ID_MASK_SHIFT;\n  function unpackModuleId(moduleId) {\n    var segmentId = moduleId >>> ID_MASK_SHIFT;\n    var localId = moduleId & LOCAL_ID_MASK;\n    return {\n      segmentId: segmentId,\n      localId: localId\n    };\n  }\n  metroRequire.unpackModuleId = unpackModuleId;\n  function packModuleId(value) {\n    return (value.segmentId << ID_MASK_SHIFT) + value.localId;\n  }\n  metroRequire.packModuleId = packModuleId;\n  var moduleDefinersBySegmentID = [];\n  var definingSegmentByModuleID = new Map();\n  function registerSegment(segmentId, moduleDefiner, moduleIds) {\n    moduleDefinersBySegmentID[segmentId] = moduleDefiner;\n    if (__DEV__) {\n      if (segmentId === 0 && moduleIds) {\n        throw new Error(\"registerSegment: Expected moduleIds to be null for main segment\");\n      }\n      if (segmentId !== 0 && !moduleIds) {\n        throw new Error(\"registerSegment: Expected moduleIds to be passed for segment #\" + segmentId);\n      }\n    }\n    if (moduleIds) {\n      moduleIds.forEach(function (moduleId) {\n        if (!modules.has(moduleId) && !definingSegmentByModuleID.has(moduleId)) {\n          definingSegmentByModuleID.set(moduleId, segmentId);\n        }\n      });\n    }\n  }\n  function loadModuleImplementation(moduleId, module) {\n    if (!module && moduleDefinersBySegmentID.length > 0) {\n      var _definingSegmentByMod;\n      var segmentId = (_definingSegmentByMod = definingSegmentByModuleID.get(moduleId)) != null ? _definingSegmentByMod : 0;\n      var definer = moduleDefinersBySegmentID[segmentId];\n      if (definer != null) {\n        definer(moduleId);\n        module = modules.get(moduleId);\n        definingSegmentByModuleID.delete(moduleId);\n      }\n    }\n    var nativeRequire = global.nativeRequire;\n    if (!module && nativeRequire) {\n      var _unpackModuleId = unpackModuleId(moduleId),\n        _segmentId = _unpackModuleId.segmentId,\n        localId = _unpackModuleId.localId;\n      nativeRequire(localId, _segmentId);\n      module = modules.get(moduleId);\n    }\n    if (!module) {\n      throw unknownModuleError(moduleId);\n    }\n    if (module.hasError) {\n      throw module.error;\n    }\n    if (__DEV__) {\n      var Systrace = requireSystrace();\n      var Refresh = requireRefresh();\n    }\n    module.isInitialized = true;\n    var _module = module,\n      factory = _module.factory,\n      dependencyMap = _module.dependencyMap;\n    if (__DEV__) {\n      initializingModuleIds.push(moduleId);\n    }\n    try {\n      if (__DEV__) {\n        Systrace.beginEvent(\"JS_require_\" + (module.verboseName || moduleId));\n      }\n      var moduleObject = module.publicModule;\n      if (__DEV__) {\n        moduleObject.hot = module.hot;\n        var prevRefreshReg = global.$RefreshReg$;\n        var prevRefreshSig = global.$RefreshSig$;\n        if (Refresh != null) {\n          var RefreshRuntime = Refresh;\n          global.$RefreshReg$ = function (type, id) {\n            RefreshRuntime.register(type, moduleId + \" \" + id);\n          };\n          global.$RefreshSig$ = RefreshRuntime.createSignatureFunctionForTransform;\n        }\n      }\n      moduleObject.id = moduleId;\n      factory(global, metroRequire, metroImportDefault, metroImportAll, moduleObject, moduleObject.exports, dependencyMap);\n      if (!__DEV__) {\n        module.factory = undefined;\n        module.dependencyMap = undefined;\n      }\n      if (__DEV__) {\n        Systrace.endEvent();\n        if (Refresh != null) {\n          registerExportsForReactRefresh(Refresh, moduleObject.exports, moduleId);\n        }\n      }\n      return moduleObject.exports;\n    } catch (e) {\n      module.hasError = true;\n      module.error = e;\n      module.isInitialized = false;\n      module.publicModule.exports = undefined;\n      throw e;\n    } finally {\n      if (__DEV__) {\n        if (initializingModuleIds.pop() !== moduleId) {\n          throw new Error(\"initializingModuleIds is corrupt; something is terribly wrong\");\n        }\n        global.$RefreshReg$ = prevRefreshReg;\n        global.$RefreshSig$ = prevRefreshSig;\n      }\n    }\n  }\n  function unknownModuleError(id) {\n    var message = 'Requiring unknown module \"' + id + '\".';\n    if (__DEV__) {\n      message += \" If you are sure the module exists, try restarting Metro. \" + \"You may also want to run `yarn` or `npm install`.\";\n    }\n    return Error(message);\n  }\n  if (__DEV__) {\n    metroRequire.Systrace = {\n      beginEvent: function beginEvent() {},\n      endEvent: function endEvent() {}\n    };\n    metroRequire.getModules = function () {\n      return modules;\n    };\n    var createHotReloadingObject = function createHotReloadingObject() {\n      var hot = {\n        _acceptCallback: null,\n        _disposeCallback: null,\n        _didAccept: false,\n        accept: function accept(callback) {\n          hot._didAccept = true;\n          hot._acceptCallback = callback;\n        },\n        dispose: function dispose(callback) {\n          hot._disposeCallback = callback;\n        }\n      };\n      return hot;\n    };\n    var reactRefreshTimeout = null;\n    var metroHotUpdateModule = function metroHotUpdateModule(id, factory, dependencyMap, inverseDependencies) {\n      var mod = modules.get(id);\n      if (!mod) {\n        if (factory) {\n          return;\n        }\n        throw unknownModuleError(id);\n      }\n      if (!mod.hasError && !mod.isInitialized) {\n        mod.factory = factory;\n        mod.dependencyMap = dependencyMap;\n        return;\n      }\n      var Refresh = requireRefresh();\n      var refreshBoundaryIDs = new Set();\n      var didBailOut = false;\n      var updatedModuleIDs;\n      try {\n        updatedModuleIDs = topologicalSort([id], function (pendingID) {\n          var pendingModule = modules.get(pendingID);\n          if (pendingModule == null) {\n            return [];\n          }\n          var pendingHot = pendingModule.hot;\n          if (pendingHot == null) {\n            throw new Error(\"[Refresh] Expected module.hot to always exist in DEV.\");\n          }\n          var canAccept = pendingHot._didAccept;\n          if (!canAccept && Refresh != null) {\n            var isBoundary = isReactRefreshBoundary(Refresh, pendingModule.publicModule.exports);\n            if (isBoundary) {\n              canAccept = true;\n              refreshBoundaryIDs.add(pendingID);\n            }\n          }\n          if (canAccept) {\n            return [];\n          }\n          var parentIDs = inverseDependencies[pendingID];\n          if (parentIDs.length === 0) {\n            performFullRefresh(\"No root boundary\", {\n              source: mod,\n              failed: pendingModule\n            });\n            didBailOut = true;\n            return [];\n          }\n          return parentIDs;\n        }, function () {\n          return didBailOut;\n        }).reverse();\n      } catch (e) {\n        if (e === CYCLE_DETECTED) {\n          performFullRefresh(\"Dependency cycle\", {\n            source: mod\n          });\n          return;\n        }\n        throw e;\n      }\n      if (didBailOut) {\n        return;\n      }\n      var seenModuleIDs = new Set();\n      for (var i = 0; i < updatedModuleIDs.length; i++) {\n        var updatedID = updatedModuleIDs[i];\n        if (seenModuleIDs.has(updatedID)) {\n          continue;\n        }\n        seenModuleIDs.add(updatedID);\n        var updatedMod = modules.get(updatedID);\n        if (updatedMod == null) {\n          throw new Error(\"[Refresh] Expected to find the updated module.\");\n        }\n        var prevExports = updatedMod.publicModule.exports;\n        var didError = runUpdatedModule(updatedID, updatedID === id ? factory : undefined, updatedID === id ? dependencyMap : undefined);\n        var nextExports = updatedMod.publicModule.exports;\n        if (didError) {\n          return;\n        }\n        if (refreshBoundaryIDs.has(updatedID)) {\n          var isNoLongerABoundary = !isReactRefreshBoundary(Refresh, nextExports);\n          var didInvalidate = shouldInvalidateReactRefreshBoundary(Refresh, prevExports, nextExports);\n          if (isNoLongerABoundary || didInvalidate) {\n            var parentIDs = inverseDependencies[updatedID];\n            if (parentIDs.length === 0) {\n              performFullRefresh(isNoLongerABoundary ? \"No longer a boundary\" : \"Invalidated boundary\", {\n                source: mod,\n                failed: updatedMod\n              });\n              return;\n            }\n            for (var j = 0; j < parentIDs.length; j++) {\n              var parentID = parentIDs[j];\n              var parentMod = modules.get(parentID);\n              if (parentMod == null) {\n                throw new Error(\"[Refresh] Expected to find parent module.\");\n              }\n              var canAcceptParent = isReactRefreshBoundary(Refresh, parentMod.publicModule.exports);\n              if (canAcceptParent) {\n                refreshBoundaryIDs.add(parentID);\n                updatedModuleIDs.push(parentID);\n              } else {\n                performFullRefresh(\"Invalidated boundary\", {\n                  source: mod,\n                  failed: parentMod\n                });\n                return;\n              }\n            }\n          }\n        }\n      }\n      if (Refresh != null) {\n        if (reactRefreshTimeout == null) {\n          reactRefreshTimeout = setTimeout(function () {\n            reactRefreshTimeout = null;\n            Refresh.performReactRefresh();\n          }, 30);\n        }\n      }\n    };\n    var topologicalSort = function topologicalSort(roots, getEdges, earlyStop) {\n      var result = [];\n      var visited = new Set();\n      var stack = new Set();\n      function traverseDependentNodes(node) {\n        if (stack.has(node)) {\n          throw CYCLE_DETECTED;\n        }\n        if (visited.has(node)) {\n          return;\n        }\n        visited.add(node);\n        stack.add(node);\n        var dependentNodes = getEdges(node);\n        if (earlyStop(node)) {\n          stack.delete(node);\n          return;\n        }\n        dependentNodes.forEach(function (dependent) {\n          traverseDependentNodes(dependent);\n        });\n        stack.delete(node);\n        result.push(node);\n      }\n      roots.forEach(function (root) {\n        traverseDependentNodes(root);\n      });\n      return result;\n    };\n    var runUpdatedModule = function runUpdatedModule(id, factory, dependencyMap) {\n      var mod = modules.get(id);\n      if (mod == null) {\n        throw new Error(\"[Refresh] Expected to find the module.\");\n      }\n      var hot = mod.hot;\n      if (!hot) {\n        throw new Error(\"[Refresh] Expected module.hot to always exist in DEV.\");\n      }\n      if (hot._disposeCallback) {\n        try {\n          hot._disposeCallback();\n        } catch (error) {\n          console.error(`Error while calling dispose handler for module ${id}: `, error);\n        }\n      }\n      if (factory) {\n        mod.factory = factory;\n      }\n      if (dependencyMap) {\n        mod.dependencyMap = dependencyMap;\n      }\n      mod.hasError = false;\n      mod.error = undefined;\n      mod.importedAll = EMPTY;\n      mod.importedDefault = EMPTY;\n      mod.isInitialized = false;\n      var prevExports = mod.publicModule.exports;\n      mod.publicModule.exports = {};\n      hot._didAccept = false;\n      hot._acceptCallback = null;\n      hot._disposeCallback = null;\n      metroRequire(id);\n      if (mod.hasError) {\n        mod.hasError = false;\n        mod.isInitialized = true;\n        mod.error = null;\n        mod.publicModule.exports = prevExports;\n        return true;\n      }\n      if (hot._acceptCallback) {\n        try {\n          hot._acceptCallback();\n        } catch (error) {\n          console.error(`Error while calling accept handler for module ${id}: `, error);\n        }\n      }\n      return false;\n    };\n    var performFullRefresh = function performFullRefresh(reason, modules) {\n      if (typeof window !== \"undefined\" && window.location != null && typeof window.location.reload === \"function\") {\n        window.location.reload();\n      } else {\n        var Refresh = requireRefresh();\n        if (Refresh != null) {\n          var _modules$source$verbo, _modules$source, _modules$failed$verbo, _modules$failed;\n          var sourceName = (_modules$source$verbo = (_modules$source = modules.source) == null ? void 0 : _modules$source.verboseName) != null ? _modules$source$verbo : \"unknown\";\n          var failedName = (_modules$failed$verbo = (_modules$failed = modules.failed) == null ? void 0 : _modules$failed.verboseName) != null ? _modules$failed$verbo : \"unknown\";\n          Refresh.performFullRefresh(`Fast Refresh - ${reason} <${sourceName}> <${failedName}>`);\n        } else {\n          console.warn(\"Could not reload the application after an edit.\");\n        }\n      }\n    };\n    var isReactRefreshBoundary = function isReactRefreshBoundary(Refresh, moduleExports) {\n      if (Refresh.isLikelyComponentType(moduleExports)) {\n        return true;\n      }\n      if (moduleExports == null || typeof moduleExports !== \"object\") {\n        return false;\n      }\n      var hasExports = false;\n      var areAllExportsComponents = true;\n      for (var key in moduleExports) {\n        hasExports = true;\n        if (key === \"__esModule\") {\n          continue;\n        }\n        var desc = Object.getOwnPropertyDescriptor(moduleExports, key);\n        if (desc && desc.get) {\n          return false;\n        }\n        var exportValue = moduleExports[key];\n        if (!Refresh.isLikelyComponentType(exportValue)) {\n          areAllExportsComponents = false;\n        }\n      }\n      return hasExports && areAllExportsComponents;\n    };\n    var shouldInvalidateReactRefreshBoundary = function shouldInvalidateReactRefreshBoundary(Refresh, prevExports, nextExports) {\n      var prevSignature = getRefreshBoundarySignature(Refresh, prevExports);\n      var nextSignature = getRefreshBoundarySignature(Refresh, nextExports);\n      if (prevSignature.length !== nextSignature.length) {\n        return true;\n      }\n      for (var i = 0; i < nextSignature.length; i++) {\n        if (prevSignature[i] !== nextSignature[i]) {\n          return true;\n        }\n      }\n      return false;\n    };\n    var getRefreshBoundarySignature = function getRefreshBoundarySignature(Refresh, moduleExports) {\n      var signature = [];\n      signature.push(Refresh.getFamilyByType(moduleExports));\n      if (moduleExports == null || typeof moduleExports !== \"object\") {\n        return signature;\n      }\n      for (var key in moduleExports) {\n        if (key === \"__esModule\") {\n          continue;\n        }\n        var desc = Object.getOwnPropertyDescriptor(moduleExports, key);\n        if (desc && desc.get) {\n          continue;\n        }\n        var exportValue = moduleExports[key];\n        signature.push(key);\n        signature.push(Refresh.getFamilyByType(exportValue));\n      }\n      return signature;\n    };\n    var registerExportsForReactRefresh = function registerExportsForReactRefresh(Refresh, moduleExports, moduleID) {\n      Refresh.register(moduleExports, moduleID + \" %exports%\");\n      if (moduleExports == null || typeof moduleExports !== \"object\") {\n        return;\n      }\n      for (var key in moduleExports) {\n        var desc = Object.getOwnPropertyDescriptor(moduleExports, key);\n        if (desc && desc.get) {\n          continue;\n        }\n        var exportValue = moduleExports[key];\n        var typeID = moduleID + \" %exports% \" + key;\n        Refresh.register(exportValue, typeID);\n      }\n    };\n    global.__accept = metroHotUpdateModule;\n  }\n  if (__DEV__) {\n    var requireSystrace = function requireSystrace() {\n      return global[__METRO_GLOBAL_PREFIX__ + \"__SYSTRACE\"] || metroRequire.Systrace;\n    };\n    var requireRefresh = function requireRefresh() {\n      return global[__METRO_GLOBAL_PREFIX__ + \"__ReactRefresh\"] || metroRequire.Refresh;\n    };\n  }\n})(typeof globalThis !== 'undefined' ? globalThis : typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : this);\n(function (global) {\n  /**\n   * Copyright (c) Meta Platforms, Inc. and affiliates.\n   *\n   * This source code is licensed under the MIT license found in the\n   * LICENSE file in the root directory of this source tree.\n   *\n   * @polyfill\n   * @nolint\n   * @format\n   */\n\n  /* eslint-disable no-shadow, eqeqeq, curly, no-unused-vars, no-void, no-control-regex  */\n\n  /**\n   * This pipes all of our console logging functions to native logging so that\n   * JavaScript errors in required modules show up in Xcode via NSLog.\n   */\n  var inspect = function () {\n    // Copyright Joyent, Inc. and other Node contributors.\n    //\n    // Permission is hereby granted, free of charge, to any person obtaining a\n    // copy of this software and associated documentation files (the\n    // \"Software\"), to deal in the Software without restriction, including\n    // without limitation the rights to use, copy, modify, merge, publish,\n    // distribute, sublicense, and/or sell copies of the Software, and to permit\n    // persons to whom the Software is furnished to do so, subject to the\n    // following conditions:\n    //\n    // The above copyright notice and this permission notice shall be included\n    // in all copies or substantial portions of the Software.\n    //\n    // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n    // USE OR OTHER DEALINGS IN THE SOFTWARE.\n    //\n    // https://github.com/joyent/node/blob/master/lib/util.js\n\n    function inspect(obj, opts) {\n      var ctx = {\n        seen: [],\n        formatValueCalls: 0,\n        stylize: stylizeNoColor\n      };\n      return formatValue(ctx, obj, opts.depth);\n    }\n    function stylizeNoColor(str, styleType) {\n      return str;\n    }\n    function arrayToHash(array) {\n      var hash = {};\n      array.forEach(function (val, idx) {\n        hash[val] = true;\n      });\n      return hash;\n    }\n    function formatValue(ctx, value, recurseTimes) {\n      ctx.formatValueCalls++;\n      if (ctx.formatValueCalls > 200) {\n        return `[TOO BIG formatValueCalls ${ctx.formatValueCalls} exceeded limit of 200]`;\n      }\n\n      // Primitive types cannot have properties\n      var primitive = formatPrimitive(ctx, value);\n      if (primitive) {\n        return primitive;\n      }\n\n      // Look up the keys of the object.\n      var keys = Object.keys(value);\n      var visibleKeys = arrayToHash(keys);\n\n      // IE doesn't make error fields non-enumerable\n      // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n      if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n        return formatError(value);\n      }\n\n      // Some type of object without properties can be shortcutted.\n      if (keys.length === 0) {\n        if (isFunction(value)) {\n          var name = value.name ? ': ' + value.name : '';\n          return ctx.stylize('[Function' + name + ']', 'special');\n        }\n        if (isRegExp(value)) {\n          return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n        }\n        if (isDate(value)) {\n          return ctx.stylize(Date.prototype.toString.call(value), 'date');\n        }\n        if (isError(value)) {\n          return formatError(value);\n        }\n      }\n      var base = '',\n        array = false,\n        braces = ['{', '}'];\n\n      // Make Array say that they are Array\n      if (isArray(value)) {\n        array = true;\n        braces = ['[', ']'];\n      }\n\n      // Make functions say that they are functions\n      if (isFunction(value)) {\n        var n = value.name ? ': ' + value.name : '';\n        base = ' [Function' + n + ']';\n      }\n\n      // Make RegExps say that they are RegExps\n      if (isRegExp(value)) {\n        base = ' ' + RegExp.prototype.toString.call(value);\n      }\n\n      // Make dates with properties first say the date\n      if (isDate(value)) {\n        base = ' ' + Date.prototype.toUTCString.call(value);\n      }\n\n      // Make error with message first say the error\n      if (isError(value)) {\n        base = ' ' + formatError(value);\n      }\n      if (keys.length === 0 && (!array || value.length == 0)) {\n        return braces[0] + base + braces[1];\n      }\n      if (recurseTimes < 0) {\n        if (isRegExp(value)) {\n          return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n        } else {\n          return ctx.stylize('[Object]', 'special');\n        }\n      }\n      ctx.seen.push(value);\n      var output;\n      if (array) {\n        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n      } else {\n        output = keys.map(function (key) {\n          return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n        });\n      }\n      ctx.seen.pop();\n      return reduceToSingleString(output, base, braces);\n    }\n    function formatPrimitive(ctx, value) {\n      if (isUndefined(value)) return ctx.stylize('undefined', 'undefined');\n      if (isString(value)) {\n        var simple = \"'\" + JSON.stringify(value).replace(/^\"|\"$/g, '').replace(/'/g, \"\\\\'\").replace(/\\\\\"/g, '\"') + \"'\";\n        return ctx.stylize(simple, 'string');\n      }\n      if (isNumber(value)) return ctx.stylize('' + value, 'number');\n      if (isBoolean(value)) return ctx.stylize('' + value, 'boolean');\n      // For some reason typeof null is \"object\", so special case here.\n      if (isNull(value)) return ctx.stylize('null', 'null');\n    }\n    function formatError(value) {\n      return '[' + Error.prototype.toString.call(value) + ']';\n    }\n    function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n      var output = [];\n      for (var i = 0, l = value.length; i < l; ++i) {\n        if (hasOwnProperty(value, String(i))) {\n          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));\n        } else {\n          output.push('');\n        }\n      }\n      keys.forEach(function (key) {\n        if (!key.match(/^\\d+$/)) {\n          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));\n        }\n      });\n      return output;\n    }\n    function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n      var name, str, desc;\n      desc = Object.getOwnPropertyDescriptor(value, key) || {\n        value: value[key]\n      };\n      if (desc.get) {\n        if (desc.set) {\n          str = ctx.stylize('[Getter/Setter]', 'special');\n        } else {\n          str = ctx.stylize('[Getter]', 'special');\n        }\n      } else {\n        if (desc.set) {\n          str = ctx.stylize('[Setter]', 'special');\n        }\n      }\n      if (!hasOwnProperty(visibleKeys, key)) {\n        name = '[' + key + ']';\n      }\n      if (!str) {\n        if (ctx.seen.indexOf(desc.value) < 0) {\n          if (isNull(recurseTimes)) {\n            str = formatValue(ctx, desc.value, null);\n          } else {\n            str = formatValue(ctx, desc.value, recurseTimes - 1);\n          }\n          if (str.indexOf('\\n') > -1) {\n            if (array) {\n              str = str.split('\\n').map(function (line) {\n                return '  ' + line;\n              }).join('\\n').slice(2);\n            } else {\n              str = '\\n' + str.split('\\n').map(function (line) {\n                return '   ' + line;\n              }).join('\\n');\n            }\n          }\n        } else {\n          str = ctx.stylize('[Circular]', 'special');\n        }\n      }\n      if (isUndefined(name)) {\n        if (array && key.match(/^\\d+$/)) {\n          return str;\n        }\n        name = JSON.stringify('' + key);\n        if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n          name = name.slice(1, name.length - 1);\n          name = ctx.stylize(name, 'name');\n        } else {\n          name = name.replace(/'/g, \"\\\\'\").replace(/\\\\\"/g, '\"').replace(/(^\"|\"$)/g, \"'\");\n          name = ctx.stylize(name, 'string');\n        }\n      }\n      return name + ': ' + str;\n    }\n    function reduceToSingleString(output, base, braces) {\n      var numLinesEst = 0;\n      var length = output.reduce(function (prev, cur) {\n        numLinesEst++;\n        if (cur.indexOf('\\n') >= 0) numLinesEst++;\n        return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n      }, 0);\n      if (length > 60) {\n        return braces[0] + (base === '' ? '' : base + '\\n ') + ' ' + output.join(',\\n  ') + ' ' + braces[1];\n      }\n      return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n    }\n\n    // NOTE: These type checking functions intentionally don't use `instanceof`\n    // because it is fragile and can be easily faked with `Object.create()`.\n    function isArray(ar) {\n      return Array.isArray(ar);\n    }\n    function isBoolean(arg) {\n      return typeof arg === 'boolean';\n    }\n    function isNull(arg) {\n      return arg === null;\n    }\n    function isNullOrUndefined(arg) {\n      return arg == null;\n    }\n    function isNumber(arg) {\n      return typeof arg === 'number';\n    }\n    function isString(arg) {\n      return typeof arg === 'string';\n    }\n    function isSymbol(arg) {\n      return typeof arg === 'symbol';\n    }\n    function isUndefined(arg) {\n      return arg === void 0;\n    }\n    function isRegExp(re) {\n      return isObject(re) && objectToString(re) === '[object RegExp]';\n    }\n    function isObject(arg) {\n      return typeof arg === 'object' && arg !== null;\n    }\n    function isDate(d) {\n      return isObject(d) && objectToString(d) === '[object Date]';\n    }\n    function isError(e) {\n      return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);\n    }\n    function isFunction(arg) {\n      return typeof arg === 'function';\n    }\n    function objectToString(o) {\n      return Object.prototype.toString.call(o);\n    }\n    function hasOwnProperty(obj, prop) {\n      return Object.prototype.hasOwnProperty.call(obj, prop);\n    }\n    return inspect;\n  }();\n  var OBJECT_COLUMN_NAME = '(index)';\n  var LOG_LEVELS = {\n    trace: 0,\n    info: 1,\n    warn: 2,\n    error: 3\n  };\n  var INSPECTOR_LEVELS = [];\n  INSPECTOR_LEVELS[LOG_LEVELS.trace] = 'debug';\n  INSPECTOR_LEVELS[LOG_LEVELS.info] = 'log';\n  INSPECTOR_LEVELS[LOG_LEVELS.warn] = 'warning';\n  INSPECTOR_LEVELS[LOG_LEVELS.error] = 'error';\n\n  // Strip the inner function in getNativeLogFunction(), if in dev also\n  // strip method printing to originalConsole.\n  var INSPECTOR_FRAMES_TO_SKIP = __DEV__ ? 2 : 1;\n  function getNativeLogFunction(level) {\n    return function () {\n      var str;\n      if (arguments.length === 1 && typeof arguments[0] === 'string') {\n        str = arguments[0];\n      } else {\n        str = Array.prototype.map.call(arguments, function (arg) {\n          return inspect(arg, {\n            depth: 10\n          });\n        }).join(', ');\n      }\n\n      // TRICKY\n      // If more than one argument is provided, the code above collapses them all\n      // into a single formatted string. This transform wraps string arguments in\n      // single quotes (e.g. \"foo\" -> \"'foo'\") which then breaks the \"Warning:\"\n      // check below. So it's important that we look at the first argument, rather\n      // than the formatted argument string.\n      var firstArg = arguments[0];\n      var logLevel = level;\n      if (typeof firstArg === 'string' && firstArg.slice(0, 9) === 'Warning: ' && logLevel >= LOG_LEVELS.error) {\n        // React warnings use console.error so that a stack trace is shown,\n        // but we don't (currently) want these to show a redbox\n        // (Note: Logic duplicated in ExceptionsManager.js.)\n        logLevel = LOG_LEVELS.warn;\n      }\n      if (global.__inspectorLog) {\n        global.__inspectorLog(INSPECTOR_LEVELS[logLevel], str, [].slice.call(arguments), INSPECTOR_FRAMES_TO_SKIP);\n      }\n      if (groupStack.length) {\n        str = groupFormat('', str);\n      }\n      global.nativeLoggingHook(str, logLevel);\n    };\n  }\n  function repeat(element, n) {\n    return Array.apply(null, Array(n)).map(function () {\n      return element;\n    });\n  }\n  function consoleTablePolyfill(rows) {\n    // convert object -> array\n    if (!Array.isArray(rows)) {\n      var data = rows;\n      rows = [];\n      for (var key in data) {\n        if (data.hasOwnProperty(key)) {\n          var row = data[key];\n          row[OBJECT_COLUMN_NAME] = key;\n          rows.push(row);\n        }\n      }\n    }\n    if (rows.length === 0) {\n      global.nativeLoggingHook('', LOG_LEVELS.info);\n      return;\n    }\n    var columns = Object.keys(rows[0]).sort();\n    var stringRows = [];\n    var columnWidths = [];\n\n    // Convert each cell to a string. Also\n    // figure out max cell width for each column\n    columns.forEach(function (k, i) {\n      columnWidths[i] = k.length;\n      for (var j = 0; j < rows.length; j++) {\n        var cellStr = (rows[j][k] || '?').toString();\n        stringRows[j] = stringRows[j] || [];\n        stringRows[j][i] = cellStr;\n        columnWidths[i] = Math.max(columnWidths[i], cellStr.length);\n      }\n    });\n\n    // Join all elements in the row into a single string with | separators\n    // (appends extra spaces to each cell to make separators  | aligned)\n    function joinRow(row, space) {\n      var cells = row.map(function (cell, i) {\n        var extraSpaces = repeat(' ', columnWidths[i] - cell.length).join('');\n        return cell + extraSpaces;\n      });\n      space = space || ' ';\n      return cells.join(space + '|' + space);\n    }\n    var separators = columnWidths.map(function (columnWidth) {\n      return repeat('-', columnWidth).join('');\n    });\n    var separatorRow = joinRow(separators, '-');\n    var header = joinRow(columns);\n    var table = [header, separatorRow];\n    for (var i = 0; i < rows.length; i++) {\n      table.push(joinRow(stringRows[i]));\n    }\n\n    // Notice extra empty line at the beginning.\n    // Native logging hook adds \"RCTLog >\" at the front of every\n    // logged string, which would shift the header and screw up\n    // the table\n    global.nativeLoggingHook('\\n' + table.join('\\n'), LOG_LEVELS.info);\n  }\n  var GROUP_PAD = \"\\u2502\"; // Box light vertical\n  var GROUP_OPEN = \"\\u2510\"; // Box light down+left\n  var GROUP_CLOSE = \"\\u2518\"; // Box light up+left\n\n  var groupStack = [];\n  function groupFormat(prefix, msg) {\n    // Insert group formatting before the console message\n    return groupStack.join('') + prefix + ' ' + (msg || '');\n  }\n  function consoleGroupPolyfill(label) {\n    global.nativeLoggingHook(groupFormat(GROUP_OPEN, label), LOG_LEVELS.info);\n    groupStack.push(GROUP_PAD);\n  }\n  function consoleGroupCollapsedPolyfill(label) {\n    global.nativeLoggingHook(groupFormat(GROUP_CLOSE, label), LOG_LEVELS.info);\n    groupStack.push(GROUP_PAD);\n  }\n  function consoleGroupEndPolyfill() {\n    groupStack.pop();\n    global.nativeLoggingHook(groupFormat(GROUP_CLOSE), LOG_LEVELS.info);\n  }\n  function consoleAssertPolyfill(expression, label) {\n    if (!expression) {\n      global.nativeLoggingHook('Assertion failed: ' + label, LOG_LEVELS.error);\n    }\n  }\n  if (global.nativeLoggingHook) {\n    var originalConsole = global.console;\n    // Preserve the original `console` as `originalConsole`\n    if (__DEV__ && originalConsole) {\n      var descriptor = Object.getOwnPropertyDescriptor(global, 'console');\n      if (descriptor) {\n        Object.defineProperty(global, 'originalConsole', descriptor);\n      }\n    }\n    global.console = {\n      error: getNativeLogFunction(LOG_LEVELS.error),\n      info: getNativeLogFunction(LOG_LEVELS.info),\n      log: getNativeLogFunction(LOG_LEVELS.info),\n      warn: getNativeLogFunction(LOG_LEVELS.warn),\n      trace: getNativeLogFunction(LOG_LEVELS.trace),\n      debug: getNativeLogFunction(LOG_LEVELS.trace),\n      table: consoleTablePolyfill,\n      group: consoleGroupPolyfill,\n      groupEnd: consoleGroupEndPolyfill,\n      groupCollapsed: consoleGroupCollapsedPolyfill,\n      assert: consoleAssertPolyfill\n    };\n    Object.defineProperty(console, '_isPolyfilled', {\n      value: true,\n      enumerable: false\n    });\n\n    // If available, also call the original `console` method since that is\n    // sometimes useful. Ex: on OS X, this will let you see rich output in\n    // the Safari Web Inspector console.\n    if (__DEV__ && originalConsole) {\n      Object.keys(console).forEach(function (methodName) {\n        var reactNativeMethod = console[methodName];\n        if (originalConsole[methodName]) {\n          console[methodName] = function () {\n            originalConsole[methodName].apply(originalConsole, arguments);\n            reactNativeMethod.apply(console, arguments);\n          };\n        }\n      });\n\n      // The following methods are not supported by this polyfill but\n      // we still should pass them to original console if they are\n      // supported by it.\n      ['clear', 'dir', 'dirxml', 'profile', 'profileEnd'].forEach(function (methodName) {\n        if (typeof originalConsole[methodName] === 'function') {\n          console[methodName] = function () {\n            originalConsole[methodName].apply(originalConsole, arguments);\n          };\n        }\n      });\n    }\n  } else if (!global.console) {\n    var stub = function stub() {};\n    var log = global.print || stub;\n    global.console = {\n      debug: log,\n      error: log,\n      info: log,\n      log: log,\n      trace: log,\n      warn: log,\n      assert: function assert(expression, label) {\n        if (!expression) {\n          log('Assertion failed: ' + label);\n        }\n      },\n      clear: stub,\n      dir: stub,\n      dirxml: stub,\n      group: stub,\n      groupCollapsed: stub,\n      groupEnd: stub,\n      profile: stub,\n      profileEnd: stub,\n      table: stub\n    };\n    Object.defineProperty(console, '_isPolyfilled', {\n      value: true,\n      enumerable: false\n    });\n  }\n})(typeof globalThis !== 'undefined' ? globalThis : typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : this);\n(function (global) {\n  /**\n   * Copyright (c) Meta Platforms, Inc. and affiliates.\n   *\n   * This source code is licensed under the MIT license found in the\n   * LICENSE file in the root directory of this source tree.\n   *\n   * @format\n   * \n   * @polyfill\n   */\n\n  var _inGuard = 0;\n  /**\n   * This is the error handler that is called when we encounter an exception\n   * when loading a module. This will report any errors encountered before\n   * ExceptionsManager is configured.\n   */\n  var _globalHandler = function onError(e, isFatal) {\n    throw e;\n  };\n\n  /**\n   * The particular require runtime that we are using looks for a global\n   * `ErrorUtils` object and if it exists, then it requires modules with the\n   * error handler specified via ErrorUtils.setGlobalHandler by calling the\n   * require function with applyWithGuard. Since the require module is loaded\n   * before any of the modules, this ErrorUtils must be defined (and the handler\n   * set) globally before requiring anything.\n   */\n  var ErrorUtils = {\n    setGlobalHandler: function setGlobalHandler(fun) {\n      _globalHandler = fun;\n    },\n    getGlobalHandler: function getGlobalHandler() {\n      return _globalHandler;\n    },\n    reportError: function reportError(error) {\n      _globalHandler && _globalHandler(error, false);\n    },\n    reportFatalError: function reportFatalError(error) {\n      // NOTE: This has an untyped call site in Metro.\n      _globalHandler && _globalHandler(error, true);\n    },\n    applyWithGuard: function applyWithGuard(fun, context, args,\n    // Unused, but some code synced from www sets it to null.\n    unused_onError,\n    // Some callers pass a name here, which we ignore.\n    unused_name) {\n      try {\n        _inGuard++;\n        /* $FlowFixMe[incompatible-call] : TODO T48204745 (1) apply(context,\n         * null) is fine. (2) array -> rest array should work */\n        /* $FlowFixMe[incompatible-type] : TODO T48204745 (1) apply(context,\n         * null) is fine. (2) array -> rest array should work */\n        return fun.apply(context, args);\n      } catch (e) {\n        ErrorUtils.reportError(e);\n      } finally {\n        _inGuard--;\n      }\n      return null;\n    },\n    applyWithGuardIfNeeded: function applyWithGuardIfNeeded(fun, context, args) {\n      if (ErrorUtils.inGuard()) {\n        /* $FlowFixMe[incompatible-call] : TODO T48204745 (1) apply(context,\n         * null) is fine. (2) array -> rest array should work */\n        /* $FlowFixMe[incompatible-type] : TODO T48204745 (1) apply(context,\n         * null) is fine. (2) array -> rest array should work */\n        return fun.apply(context, args);\n      } else {\n        ErrorUtils.applyWithGuard(fun, context, args);\n      }\n      return null;\n    },\n    inGuard: function inGuard() {\n      return !!_inGuard;\n    },\n    guard: function guard(fun, name, context) {\n      var _ref;\n      // TODO: (moti) T48204753 Make sure this warning is never hit and remove it - types\n      // should be sufficient.\n      if (typeof fun !== 'function') {\n        console.warn('A function must be passed to ErrorUtils.guard, got ', fun);\n        return null;\n      }\n      var guardName = (_ref = name != null ? name : fun.name) != null ? _ref : '<generated guard>';\n      /* $FlowFixMe[missing-this-annot] The 'this' type annotation(s) required by\n       * Flow's LTI update could not be added via codemod */\n      function guarded() {\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n        return ErrorUtils.applyWithGuard(fun, context != null ? context : this, args, null, guardName);\n      }\n      return guarded;\n    }\n  };\n  global.ErrorUtils = ErrorUtils;\n})(typeof globalThis !== 'undefined' ? globalThis : typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : this);\n__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {\n  global.wgpuMatrix = {\n    vec3: _$$_REQUIRE(_dependencyMap[0], \"wgpu-matrix\").vec3,\n    mat4: _$$_REQUIRE(_dependencyMap[0], \"wgpu-matrix\").mat4\n  };\n},0,[1],\"src/Cube/wgpu-matrix.ts\");\n__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {\n  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], \"@babel/runtime/helpers/interopRequireDefault\");\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.vec4n = exports.vec4d = exports.vec4 = exports.vec3n = exports.vec3d = exports.vec3 = exports.vec2n = exports.vec2d = exports.vec2 = exports.utils = exports.quatn = exports.quatd = exports.quat = exports.mat4n = exports.mat4d = exports.mat4 = exports.mat3n = exports.mat3d = exports.mat3 = void 0;\n  var _createClass2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[1], \"@babel/runtime/helpers/createClass\"));\n  var _classCallCheck2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[2], \"@babel/runtime/helpers/classCallCheck\"));\n  var _possibleConstructorReturn2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[3], \"@babel/runtime/helpers/possibleConstructorReturn\"));\n  var _getPrototypeOf2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[4], \"@babel/runtime/helpers/getPrototypeOf\"));\n  var _inherits2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[5], \"@babel/runtime/helpers/inherits\"));\n  function _callSuper(t, o, e) { return o = (0, _getPrototypeOf2.default)(o), (0, _possibleConstructorReturn2.default)(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], (0, _getPrototypeOf2.default)(t).constructor) : o.apply(t, e)); }\n  function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\n  /* wgpu-matrix@3.3.0, license MIT */\n  function wrapConstructor(OriginalConstructor, modifier) {\n    return /*#__PURE__*/function (_OriginalConstructor) {\n      function _class() {\n        var _this;\n        (0, _classCallCheck2.default)(this, _class);\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n        _this = _callSuper(this, _class, [].concat(args));\n        modifier(_this);\n        return _this;\n      }\n      (0, _inherits2.default)(_class, _OriginalConstructor);\n      return (0, _createClass2.default)(_class);\n    }(OriginalConstructor); // Type assertion is necessary here\n  }\n  var ZeroArray = wrapConstructor(Array, function (a) {\n    return a.fill(0);\n  });\n\n  /*\n   * Copyright 2022 Gregg Tavares\n   *\n   * Permission is hereby granted, free of charge, to any person obtaining a\n   * copy of this software and associated documentation files (the \"Software\"),\n   * to deal in the Software without restriction, including without limitation\n   * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n   * and/or sell copies of the Software, and to permit persons to whom the\n   * Software is furnished to do so, subject to the following conditions:\n   *\n   * The above copyright notice and this permission notice shall be included in\n   * all copies or substantial portions of the Software.\n   *\n   * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n   * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n   * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n   * DEALINGS IN THE SOFTWARE.\n   */\n  var EPSILON = 0.000001;\n  /**\n   * Set the value for EPSILON for various checks\n   * @param v - Value to use for EPSILON.\n   * @returns previous value of EPSILON;\n   */\n  function setEpsilon(v) {\n    var old = EPSILON;\n    EPSILON = v;\n    return old;\n  }\n  /**\n   * Convert degrees to radians\n   * @param degrees - Angle in degrees\n   * @returns angle converted to radians\n   */\n  function degToRad(degrees) {\n    return degrees * Math.PI / 180;\n  }\n  /**\n   * Convert radians to degrees\n   * @param radians - Angle in radians\n   * @returns angle converted to degrees\n   */\n  function radToDeg(radians) {\n    return radians * 180 / Math.PI;\n  }\n  /**\n   * Lerps between a and b via t\n   * @param a - starting value\n   * @param b - ending value\n   * @param t - value where 0 = a and 1 = b\n   * @returns a + (b - a) * t\n   */\n  function lerp(a, b, t) {\n    return a + (b - a) * t;\n  }\n  /**\n   * Compute the opposite of lerp. Given a and b and a value between\n   * a and b returns a value between 0 and 1. 0 if a, 1 if b.\n   * Note: no clamping is done.\n   * @param a - start value\n   * @param b - end value\n   * @param v - value between a and b\n   * @returns (v - a) / (b - a)\n   */\n  function inverseLerp(a, b, v) {\n    var d = b - a;\n    return Math.abs(b - a) < EPSILON ? a : (v - a) / d;\n  }\n  /**\n   * Compute the euclidean modulo\n   *\n   * ```\n   * // table for n / 3\n   * -5, -4, -3, -2, -1,  0,  1,  2,  3,  4,  5   <- n\n   * ------------------------------------\n   * -2  -1  -0  -2  -1   0,  1,  2,  0,  1,  2   <- n % 3\n   *  1   2   0   1   2   0,  1,  2,  0,  1,  2   <- euclideanModule(n, 3)\n   * ```\n   *\n   * @param n - dividend\n   * @param m - divisor\n   * @returns the euclidean modulo of n / m\n   */\n  function euclideanModulo(n, m) {\n    return (n % m + m) % m;\n  }\n  var utils = exports.utils = {\n    __proto__: null,\n    get EPSILON() {\n      return EPSILON;\n    },\n    degToRad: degToRad,\n    euclideanModulo: euclideanModulo,\n    inverseLerp: inverseLerp,\n    lerp: lerp,\n    radToDeg: radToDeg,\n    setEpsilon: setEpsilon\n  };\n\n  /*\n   * Copyright 2022 Gregg Tavares\n   *\n   * Permission is hereby granted, free of charge, to any person obtaining a\n   * copy of this software and associated documentation files (the \"Software\"),\n   * to deal in the Software without restriction, including without limitation\n   * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n   * and/or sell copies of the Software, and to permit persons to whom the\n   * Software is furnished to do so, subject to the following conditions:\n   *\n   * The above copyright notice and this permission notice shall be included in\n   * all copies or substantial portions of the Software.\n   *\n   * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n   * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n   * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n   * DEALINGS IN THE SOFTWARE.\n   */\n  /**\n   * Generates am typed API for Vec3\n   */\n  function getAPIImpl$5(Ctor) {\n    /**\n     * Creates a Vec2; may be called with x, y, z to set initial values.\n     *\n     * Note: Since passing in a raw JavaScript array\n     * is valid in all circumstances, if you want to\n     * force a JavaScript array into a Vec2's specified type\n     * it would be faster to use\n     *\n     * ```\n     * const v = vec2.clone(someJSArray);\n     * ```\n     *\n     * @param x - Initial x value.\n     * @param y - Initial y value.\n     * @returns the created vector\n     */\n    function create() {\n      var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var newDst = new Ctor(2);\n      if (x !== undefined) {\n        newDst[0] = x;\n        if (y !== undefined) {\n          newDst[1] = y;\n        }\n      }\n      return newDst;\n    }\n    /**\n     * Creates a Vec2; may be called with x, y, z to set initial values. (same as create)\n     * @param x - Initial x value.\n     * @param y - Initial y value.\n     * @returns the created vector\n     */\n    var fromValues = create;\n    /**\n     * Sets the values of a Vec2\n     * Also see {@link vec2.create} and {@link vec2.copy}\n     *\n     * @param x first value\n     * @param y second value\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A vector with its elements set.\n     */\n    function set(x, y, dst) {\n      var newDst = dst != null ? dst : new Ctor(2);\n      newDst[0] = x;\n      newDst[1] = y;\n      return newDst;\n    }\n    /**\n     * Applies Math.ceil to each element of vector\n     * @param v - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A vector that is the ceil of each element of v.\n     */\n    function ceil(v, dst) {\n      var newDst = dst != null ? dst : new Ctor(2);\n      newDst[0] = Math.ceil(v[0]);\n      newDst[1] = Math.ceil(v[1]);\n      return newDst;\n    }\n    /**\n     * Applies Math.floor to each element of vector\n     * @param v - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A vector that is the floor of each element of v.\n     */\n    function floor(v, dst) {\n      var newDst = dst != null ? dst : new Ctor(2);\n      newDst[0] = Math.floor(v[0]);\n      newDst[1] = Math.floor(v[1]);\n      return newDst;\n    }\n    /**\n     * Applies Math.round to each element of vector\n     * @param v - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A vector that is the round of each element of v.\n     */\n    function round(v, dst) {\n      var newDst = dst != null ? dst : new Ctor(2);\n      newDst[0] = Math.round(v[0]);\n      newDst[1] = Math.round(v[1]);\n      return newDst;\n    }\n    /**\n     * Clamp each element of vector between min and max\n     * @param v - Operand vector.\n     * @param max - Min value, default 0\n     * @param min - Max value, default 1\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A vector that the clamped value of each element of v.\n     */\n    function clamp(v) {\n      var min = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var max = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n      var dst = arguments.length > 3 ? arguments[3] : undefined;\n      var newDst = dst != null ? dst : new Ctor(2);\n      newDst[0] = Math.min(max, Math.max(min, v[0]));\n      newDst[1] = Math.min(max, Math.max(min, v[1]));\n      return newDst;\n    }\n    /**\n     * Adds two vectors; assumes a and b have the same dimension.\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A vector that is the sum of a and b.\n     */\n    function add(a, b, dst) {\n      var newDst = dst != null ? dst : new Ctor(2);\n      newDst[0] = a[0] + b[0];\n      newDst[1] = a[1] + b[1];\n      return newDst;\n    }\n    /**\n     * Adds two vectors, scaling the 2nd; assumes a and b have the same dimension.\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param scale - Amount to scale b\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A vector that is the sum of a + b * scale.\n     */\n    function addScaled(a, b, scale, dst) {\n      var newDst = dst != null ? dst : new Ctor(2);\n      newDst[0] = a[0] + b[0] * scale;\n      newDst[1] = a[1] + b[1] * scale;\n      return newDst;\n    }\n    /**\n     * Returns the angle in radians between two vectors.\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @returns The angle in radians between the 2 vectors.\n     */\n    function angle(a, b) {\n      var ax = a[0];\n      var ay = a[1];\n      var bx = b[0];\n      var by = b[1];\n      var mag1 = Math.sqrt(ax * ax + ay * ay);\n      var mag2 = Math.sqrt(bx * bx + by * by);\n      var mag = mag1 * mag2;\n      var cosine = mag && dot(a, b) / mag;\n      return Math.acos(cosine);\n    }\n    /**\n     * Subtracts two vectors.\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A vector that is the difference of a and b.\n     */\n    function subtract(a, b, dst) {\n      var newDst = dst != null ? dst : new Ctor(2);\n      newDst[0] = a[0] - b[0];\n      newDst[1] = a[1] - b[1];\n      return newDst;\n    }\n    /**\n     * Subtracts two vectors.\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A vector that is the difference of a and b.\n     */\n    var sub = subtract;\n    /**\n     * Check if 2 vectors are approximately equal\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @returns true if vectors are approximately equal\n     */\n    function equalsApproximately(a, b) {\n      return Math.abs(a[0] - b[0]) < EPSILON && Math.abs(a[1] - b[1]) < EPSILON;\n    }\n    /**\n     * Check if 2 vectors are exactly equal\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @returns true if vectors are exactly equal\n     */\n    function equals(a, b) {\n      return a[0] === b[0] && a[1] === b[1];\n    }\n    /**\n     * Performs linear interpolation on two vectors.\n     * Given vectors a and b and interpolation coefficient t, returns\n     * a + t * (b - a).\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param t - Interpolation coefficient.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The linear interpolated result.\n     */\n    function lerp(a, b, t, dst) {\n      var newDst = dst != null ? dst : new Ctor(2);\n      newDst[0] = a[0] + t * (b[0] - a[0]);\n      newDst[1] = a[1] + t * (b[1] - a[1]);\n      return newDst;\n    }\n    /**\n     * Performs linear interpolation on two vectors.\n     * Given vectors a and b and interpolation coefficient vector t, returns\n     * a + t * (b - a).\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param t - Interpolation coefficients vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns the linear interpolated result.\n     */\n    function lerpV(a, b, t, dst) {\n      var newDst = dst != null ? dst : new Ctor(2);\n      newDst[0] = a[0] + t[0] * (b[0] - a[0]);\n      newDst[1] = a[1] + t[1] * (b[1] - a[1]);\n      return newDst;\n    }\n    /**\n     * Return max values of two vectors.\n     * Given vectors a and b returns\n     * [max(a[0], b[0]), max(a[1], b[1]), max(a[2], b[2])].\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The max components vector.\n     */\n    function max(a, b, dst) {\n      var newDst = dst != null ? dst : new Ctor(2);\n      newDst[0] = Math.max(a[0], b[0]);\n      newDst[1] = Math.max(a[1], b[1]);\n      return newDst;\n    }\n    /**\n     * Return min values of two vectors.\n     * Given vectors a and b returns\n     * [min(a[0], b[0]), min(a[1], b[1]), min(a[2], b[2])].\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The min components vector.\n     */\n    function min(a, b, dst) {\n      var newDst = dst != null ? dst : new Ctor(2);\n      newDst[0] = Math.min(a[0], b[0]);\n      newDst[1] = Math.min(a[1], b[1]);\n      return newDst;\n    }\n    /**\n     * Multiplies a vector by a scalar.\n     * @param v - The vector.\n     * @param k - The scalar.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The scaled vector.\n     */\n    function mulScalar(v, k, dst) {\n      var newDst = dst != null ? dst : new Ctor(2);\n      newDst[0] = v[0] * k;\n      newDst[1] = v[1] * k;\n      return newDst;\n    }\n    /**\n     * Multiplies a vector by a scalar. (same as mulScalar)\n     * @param v - The vector.\n     * @param k - The scalar.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The scaled vector.\n     */\n    var scale = mulScalar;\n    /**\n     * Divides a vector by a scalar.\n     * @param v - The vector.\n     * @param k - The scalar.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The scaled vector.\n     */\n    function divScalar(v, k, dst) {\n      var newDst = dst != null ? dst : new Ctor(2);\n      newDst[0] = v[0] / k;\n      newDst[1] = v[1] / k;\n      return newDst;\n    }\n    /**\n     * Inverse a vector.\n     * @param v - The vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The inverted vector.\n     */\n    function inverse(v, dst) {\n      var newDst = dst != null ? dst : new Ctor(2);\n      newDst[0] = 1 / v[0];\n      newDst[1] = 1 / v[1];\n      return newDst;\n    }\n    /**\n     * Invert a vector. (same as inverse)\n     * @param v - The vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The inverted vector.\n     */\n    var invert = inverse;\n    /**\n     * Computes the cross product of two vectors; assumes both vectors have\n     * three entries.\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The vector of a cross b.\n     */\n    function cross(a, b, dst) {\n      var newDst = dst != null ? dst : new Ctor(3);\n      var z = a[0] * b[1] - a[1] * b[0];\n      newDst[0] = 0;\n      newDst[1] = 0;\n      newDst[2] = z;\n      return newDst;\n    }\n    /**\n     * Computes the dot product of two vectors; assumes both vectors have\n     * three entries.\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @returns dot product\n     */\n    function dot(a, b) {\n      return a[0] * b[0] + a[1] * b[1];\n    }\n    /**\n     * Computes the length of vector\n     * @param v - vector.\n     * @returns length of vector.\n     */\n    function length(v) {\n      var v0 = v[0];\n      var v1 = v[1];\n      return Math.sqrt(v0 * v0 + v1 * v1);\n    }\n    /**\n     * Computes the length of vector (same as length)\n     * @param v - vector.\n     * @returns length of vector.\n     */\n    var len = length;\n    /**\n     * Computes the square of the length of vector\n     * @param v - vector.\n     * @returns square of the length of vector.\n     */\n    function lengthSq(v) {\n      var v0 = v[0];\n      var v1 = v[1];\n      return v0 * v0 + v1 * v1;\n    }\n    /**\n     * Computes the square of the length of vector (same as lengthSq)\n     * @param v - vector.\n     * @returns square of the length of vector.\n     */\n    var lenSq = lengthSq;\n    /**\n     * Computes the distance between 2 points\n     * @param a - vector.\n     * @param b - vector.\n     * @returns distance between a and b\n     */\n    function distance(a, b) {\n      var dx = a[0] - b[0];\n      var dy = a[1] - b[1];\n      return Math.sqrt(dx * dx + dy * dy);\n    }\n    /**\n     * Computes the distance between 2 points (same as distance)\n     * @param a - vector.\n     * @param b - vector.\n     * @returns distance between a and b\n     */\n    var dist = distance;\n    /**\n     * Computes the square of the distance between 2 points\n     * @param a - vector.\n     * @param b - vector.\n     * @returns square of the distance between a and b\n     */\n    function distanceSq(a, b) {\n      var dx = a[0] - b[0];\n      var dy = a[1] - b[1];\n      return dx * dx + dy * dy;\n    }\n    /**\n     * Computes the square of the distance between 2 points (same as distanceSq)\n     * @param a - vector.\n     * @param b - vector.\n     * @returns square of the distance between a and b\n     */\n    var distSq = distanceSq;\n    /**\n     * Divides a vector by its Euclidean length and returns the quotient.\n     * @param v - The vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The normalized vector.\n     */\n    function normalize(v, dst) {\n      var newDst = dst != null ? dst : new Ctor(2);\n      var v0 = v[0];\n      var v1 = v[1];\n      var len = Math.sqrt(v0 * v0 + v1 * v1);\n      if (len > 0.00001) {\n        newDst[0] = v0 / len;\n        newDst[1] = v1 / len;\n      } else {\n        newDst[0] = 0;\n        newDst[1] = 0;\n      }\n      return newDst;\n    }\n    /**\n     * Negates a vector.\n     * @param v - The vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns -v.\n     */\n    function negate(v, dst) {\n      var newDst = dst != null ? dst : new Ctor(2);\n      newDst[0] = -v[0];\n      newDst[1] = -v[1];\n      return newDst;\n    }\n    /**\n     * Copies a vector. (same as {@link vec2.clone})\n     * Also see {@link vec2.create} and {@link vec2.set}\n     * @param v - The vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A copy of v.\n     */\n    function copy(v, dst) {\n      var newDst = dst != null ? dst : new Ctor(2);\n      newDst[0] = v[0];\n      newDst[1] = v[1];\n      return newDst;\n    }\n    /**\n     * Clones a vector. (same as {@link vec2.copy})\n     * Also see {@link vec2.create} and {@link vec2.set}\n     * @param v - The vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A copy of v.\n     */\n    var clone = copy;\n    /**\n     * Multiplies a vector by another vector (component-wise); assumes a and\n     * b have the same length.\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The vector of products of entries of a and b.\n     */\n    function multiply(a, b, dst) {\n      var newDst = dst != null ? dst : new Ctor(2);\n      newDst[0] = a[0] * b[0];\n      newDst[1] = a[1] * b[1];\n      return newDst;\n    }\n    /**\n     * Multiplies a vector by another vector (component-wise); assumes a and\n     * b have the same length. (same as mul)\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The vector of products of entries of a and b.\n     */\n    var mul = multiply;\n    /**\n     * Divides a vector by another vector (component-wise); assumes a and\n     * b have the same length.\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The vector of quotients of entries of a and b.\n     */\n    function divide(a, b, dst) {\n      var newDst = dst != null ? dst : new Ctor(2);\n      newDst[0] = a[0] / b[0];\n      newDst[1] = a[1] / b[1];\n      return newDst;\n    }\n    /**\n     * Divides a vector by another vector (component-wise); assumes a and\n     * b have the same length. (same as divide)\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The vector of quotients of entries of a and b.\n     */\n    var div = divide;\n    /**\n     * Creates a random unit vector * scale\n     * @param scale - Default 1\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The random vector.\n     */\n    function random() {\n      var scale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n      var dst = arguments.length > 1 ? arguments[1] : undefined;\n      var newDst = dst != null ? dst : new Ctor(2);\n      var angle = Math.random() * 2 * Math.PI;\n      newDst[0] = Math.cos(angle) * scale;\n      newDst[1] = Math.sin(angle) * scale;\n      return newDst;\n    }\n    /**\n     * Zero's a vector\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The zeroed vector.\n     */\n    function zero(dst) {\n      var newDst = dst != null ? dst : new Ctor(2);\n      newDst[0] = 0;\n      newDst[1] = 0;\n      return newDst;\n    }\n    /**\n     * transform Vec2 by 4x4 matrix\n     * @param v - the vector\n     * @param m - The matrix.\n     * @param dst - optional Vec2 to store result. If not passed a new one is created.\n     * @returns the transformed vector\n     */\n    function transformMat4(v, m, dst) {\n      var newDst = dst != null ? dst : new Ctor(2);\n      var x = v[0];\n      var y = v[1];\n      newDst[0] = x * m[0] + y * m[4] + m[12];\n      newDst[1] = x * m[1] + y * m[5] + m[13];\n      return newDst;\n    }\n    /**\n     * Transforms vec4 by 3x3 matrix\n     *\n     * @param v - the vector\n     * @param m - The matrix.\n     * @param dst - optional Vec2 to store result. If not passed a new one is created.\n     * @returns the transformed vector\n     */\n    function transformMat3(v, m, dst) {\n      var newDst = dst != null ? dst : new Ctor(2);\n      var x = v[0];\n      var y = v[1];\n      newDst[0] = m[0] * x + m[4] * y + m[8];\n      newDst[1] = m[1] * x + m[5] * y + m[9];\n      return newDst;\n    }\n    /**\n     * Rotate a 2D vector\n     *\n     * @param a The vec2 point to rotate\n     * @param b The origin of the rotation\n     * @param rad The angle of rotation in radians\n     * @returns the rotated vector\n     */\n    function rotate(a, b, rad, dst) {\n      var newDst = dst != null ? dst : new Ctor(2);\n      // Translate point to the origin\n      var p0 = a[0] - b[0];\n      var p1 = a[1] - b[1];\n      var sinC = Math.sin(rad);\n      var cosC = Math.cos(rad);\n      //perform rotation and translate to correct position\n      newDst[0] = p0 * cosC - p1 * sinC + b[0];\n      newDst[1] = p0 * sinC + p1 * cosC + b[1];\n      return newDst;\n    }\n    /**\n     * Treat a 2D vector as a direction and set it's length\n     *\n     * @param a The vec2 to lengthen\n     * @param len The length of the resulting vector\n     * @returns The lengthened vector\n     */\n    function setLength(a, len, dst) {\n      var newDst = dst != null ? dst : new Ctor(2);\n      normalize(a, newDst);\n      return mulScalar(newDst, len, newDst);\n    }\n    /**\n     * Ensure a vector is not longer than a max length\n     *\n     * @param a The vec2 to limit\n     * @param maxLen The longest length of the resulting vector\n     * @returns The vector, shortened to maxLen if it's too long\n     */\n    function truncate(a, maxLen, dst) {\n      var newDst = dst != null ? dst : new Ctor(2);\n      if (length(a) > maxLen) {\n        return setLength(a, maxLen, newDst);\n      }\n      return copy(a, newDst);\n    }\n    /**\n     * Return the vector exactly between 2 endpoint vectors\n     *\n     * @param a Endpoint 1\n     * @param b Endpoint 2\n     * @returns The vector exactly residing between endpoints 1 and 2\n     */\n    function midpoint(a, b, dst) {\n      var newDst = dst != null ? dst : new Ctor(2);\n      return lerp(a, b, 0.5, newDst);\n    }\n    return {\n      create: create,\n      fromValues: fromValues,\n      set: set,\n      ceil: ceil,\n      floor: floor,\n      round: round,\n      clamp: clamp,\n      add: add,\n      addScaled: addScaled,\n      angle: angle,\n      subtract: subtract,\n      sub: sub,\n      equalsApproximately: equalsApproximately,\n      equals: equals,\n      lerp: lerp,\n      lerpV: lerpV,\n      max: max,\n      min: min,\n      mulScalar: mulScalar,\n      scale: scale,\n      divScalar: divScalar,\n      inverse: inverse,\n      invert: invert,\n      cross: cross,\n      dot: dot,\n      length: length,\n      len: len,\n      lengthSq: lengthSq,\n      lenSq: lenSq,\n      distance: distance,\n      dist: dist,\n      distanceSq: distanceSq,\n      distSq: distSq,\n      normalize: normalize,\n      negate: negate,\n      copy: copy,\n      clone: clone,\n      multiply: multiply,\n      mul: mul,\n      divide: divide,\n      div: div,\n      random: random,\n      zero: zero,\n      transformMat4: transformMat4,\n      transformMat3: transformMat3,\n      rotate: rotate,\n      setLength: setLength,\n      truncate: truncate,\n      midpoint: midpoint\n    };\n  }\n  var cache$5 = new Map();\n  function getAPI$5(Ctor) {\n    var api = cache$5.get(Ctor);\n    if (!api) {\n      api = getAPIImpl$5(Ctor);\n      cache$5.set(Ctor, api);\n    }\n    return api;\n  }\n\n  /*\n   * Copyright 2022 Gregg Tavares\n   *\n   * Permission is hereby granted, free of charge, to any person obtaining a\n   * copy of this software and associated documentation files (the \"Software\"),\n   * to deal in the Software without restriction, including without limitation\n   * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n   * and/or sell copies of the Software, and to permit persons to whom the\n   * Software is furnished to do so, subject to the following conditions:\n   *\n   * The above copyright notice and this permission notice shall be included in\n   * all copies or substantial portions of the Software.\n   *\n   * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n   * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n   * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n   * DEALINGS IN THE SOFTWARE.\n   */\n  /**\n   * Generates am typed API for Vec3\n   * */\n  function getAPIImpl$4(Ctor) {\n    /**\n     * Creates a vec3; may be called with x, y, z to set initial values.\n     * @param x - Initial x value.\n     * @param y - Initial y value.\n     * @param z - Initial z value.\n     * @returns the created vector\n     */\n    function create(x, y, z) {\n      var newDst = new Ctor(3);\n      if (x !== undefined) {\n        newDst[0] = x;\n        if (y !== undefined) {\n          newDst[1] = y;\n          if (z !== undefined) {\n            newDst[2] = z;\n          }\n        }\n      }\n      return newDst;\n    }\n    /**\n     * Creates a vec3; may be called with x, y, z to set initial values. (same as create)\n     * @param x - Initial x value.\n     * @param y - Initial y value.\n     * @param z - Initial z value.\n     * @returns the created vector\n     */\n    var fromValues = create;\n    /**\n     * Sets the values of a Vec3\n     * Also see {@link vec3.create} and {@link vec3.copy}\n     *\n     * @param x first value\n     * @param y second value\n     * @param z third value\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A vector with its elements set.\n     */\n    function set(x, y, z, dst) {\n      var newDst = dst != null ? dst : new Ctor(3);\n      newDst[0] = x;\n      newDst[1] = y;\n      newDst[2] = z;\n      return newDst;\n    }\n    /**\n     * Applies Math.ceil to each element of vector\n     * @param v - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A vector that is the ceil of each element of v.\n     */\n    function ceil(v, dst) {\n      var newDst = dst != null ? dst : new Ctor(3);\n      newDst[0] = Math.ceil(v[0]);\n      newDst[1] = Math.ceil(v[1]);\n      newDst[2] = Math.ceil(v[2]);\n      return newDst;\n    }\n    /**\n     * Applies Math.floor to each element of vector\n     * @param v - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A vector that is the floor of each element of v.\n     */\n    function floor(v, dst) {\n      var newDst = dst != null ? dst : new Ctor(3);\n      newDst[0] = Math.floor(v[0]);\n      newDst[1] = Math.floor(v[1]);\n      newDst[2] = Math.floor(v[2]);\n      return newDst;\n    }\n    /**\n     * Applies Math.round to each element of vector\n     * @param v - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A vector that is the round of each element of v.\n     */\n    function round(v, dst) {\n      var newDst = dst != null ? dst : new Ctor(3);\n      newDst[0] = Math.round(v[0]);\n      newDst[1] = Math.round(v[1]);\n      newDst[2] = Math.round(v[2]);\n      return newDst;\n    }\n    /**\n     * Clamp each element of vector between min and max\n     * @param v - Operand vector.\n     * @param max - Min value, default 0\n     * @param min - Max value, default 1\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A vector that the clamped value of each element of v.\n     */\n    function clamp(v) {\n      var min = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var max = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n      var dst = arguments.length > 3 ? arguments[3] : undefined;\n      var newDst = dst != null ? dst : new Ctor(3);\n      newDst[0] = Math.min(max, Math.max(min, v[0]));\n      newDst[1] = Math.min(max, Math.max(min, v[1]));\n      newDst[2] = Math.min(max, Math.max(min, v[2]));\n      return newDst;\n    }\n    /**\n     * Adds two vectors; assumes a and b have the same dimension.\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A vector that is the sum of a and b.\n     */\n    function add(a, b, dst) {\n      var newDst = dst != null ? dst : new Ctor(3);\n      newDst[0] = a[0] + b[0];\n      newDst[1] = a[1] + b[1];\n      newDst[2] = a[2] + b[2];\n      return newDst;\n    }\n    /**\n     * Adds two vectors, scaling the 2nd; assumes a and b have the same dimension.\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param scale - Amount to scale b\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A vector that is the sum of a + b * scale.\n     */\n    function addScaled(a, b, scale, dst) {\n      var newDst = dst != null ? dst : new Ctor(3);\n      newDst[0] = a[0] + b[0] * scale;\n      newDst[1] = a[1] + b[1] * scale;\n      newDst[2] = a[2] + b[2] * scale;\n      return newDst;\n    }\n    /**\n     * Returns the angle in radians between two vectors.\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @returns The angle in radians between the 2 vectors.\n     */\n    function angle(a, b) {\n      var ax = a[0];\n      var ay = a[1];\n      var az = a[2];\n      var bx = b[0];\n      var by = b[1];\n      var bz = b[2];\n      var mag1 = Math.sqrt(ax * ax + ay * ay + az * az);\n      var mag2 = Math.sqrt(bx * bx + by * by + bz * bz);\n      var mag = mag1 * mag2;\n      var cosine = mag && dot(a, b) / mag;\n      return Math.acos(cosine);\n    }\n    /**\n     * Subtracts two vectors.\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A vector that is the difference of a and b.\n     */\n    function subtract(a, b, dst) {\n      var newDst = dst != null ? dst : new Ctor(3);\n      newDst[0] = a[0] - b[0];\n      newDst[1] = a[1] - b[1];\n      newDst[2] = a[2] - b[2];\n      return newDst;\n    }\n    /**\n     * Subtracts two vectors.\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A vector that is the difference of a and b.\n     */\n    var sub = subtract;\n    /**\n     * Check if 2 vectors are approximately equal\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @returns true if vectors are approximately equal\n     */\n    function equalsApproximately(a, b) {\n      return Math.abs(a[0] - b[0]) < EPSILON && Math.abs(a[1] - b[1]) < EPSILON && Math.abs(a[2] - b[2]) < EPSILON;\n    }\n    /**\n     * Check if 2 vectors are exactly equal\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @returns true if vectors are exactly equal\n     */\n    function equals(a, b) {\n      return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];\n    }\n    /**\n     * Performs linear interpolation on two vectors.\n     * Given vectors a and b and interpolation coefficient t, returns\n     * a + t * (b - a).\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param t - Interpolation coefficient.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The linear interpolated result.\n     */\n    function lerp(a, b, t, dst) {\n      var newDst = dst != null ? dst : new Ctor(3);\n      newDst[0] = a[0] + t * (b[0] - a[0]);\n      newDst[1] = a[1] + t * (b[1] - a[1]);\n      newDst[2] = a[2] + t * (b[2] - a[2]);\n      return newDst;\n    }\n    /**\n     * Performs linear interpolation on two vectors.\n     * Given vectors a and b and interpolation coefficient vector t, returns\n     * a + t * (b - a).\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param t - Interpolation coefficients vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns the linear interpolated result.\n     */\n    function lerpV(a, b, t, dst) {\n      var newDst = dst != null ? dst : new Ctor(3);\n      newDst[0] = a[0] + t[0] * (b[0] - a[0]);\n      newDst[1] = a[1] + t[1] * (b[1] - a[1]);\n      newDst[2] = a[2] + t[2] * (b[2] - a[2]);\n      return newDst;\n    }\n    /**\n     * Return max values of two vectors.\n     * Given vectors a and b returns\n     * [max(a[0], b[0]), max(a[1], b[1]), max(a[2], b[2])].\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The max components vector.\n     */\n    function max(a, b, dst) {\n      var newDst = dst != null ? dst : new Ctor(3);\n      newDst[0] = Math.max(a[0], b[0]);\n      newDst[1] = Math.max(a[1], b[1]);\n      newDst[2] = Math.max(a[2], b[2]);\n      return newDst;\n    }\n    /**\n     * Return min values of two vectors.\n     * Given vectors a and b returns\n     * [min(a[0], b[0]), min(a[1], b[1]), min(a[2], b[2])].\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The min components vector.\n     */\n    function min(a, b, dst) {\n      var newDst = dst != null ? dst : new Ctor(3);\n      newDst[0] = Math.min(a[0], b[0]);\n      newDst[1] = Math.min(a[1], b[1]);\n      newDst[2] = Math.min(a[2], b[2]);\n      return newDst;\n    }\n    /**\n     * Multiplies a vector by a scalar.\n     * @param v - The vector.\n     * @param k - The scalar.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The scaled vector.\n     */\n    function mulScalar(v, k, dst) {\n      var newDst = dst != null ? dst : new Ctor(3);\n      newDst[0] = v[0] * k;\n      newDst[1] = v[1] * k;\n      newDst[2] = v[2] * k;\n      return newDst;\n    }\n    /**\n     * Multiplies a vector by a scalar. (same as mulScalar)\n     * @param v - The vector.\n     * @param k - The scalar.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The scaled vector.\n     */\n    var scale = mulScalar;\n    /**\n     * Divides a vector by a scalar.\n     * @param v - The vector.\n     * @param k - The scalar.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The scaled vector.\n     */\n    function divScalar(v, k, dst) {\n      var newDst = dst != null ? dst : new Ctor(3);\n      newDst[0] = v[0] / k;\n      newDst[1] = v[1] / k;\n      newDst[2] = v[2] / k;\n      return newDst;\n    }\n    /**\n     * Inverse a vector.\n     * @param v - The vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The inverted vector.\n     */\n    function inverse(v, dst) {\n      var newDst = dst != null ? dst : new Ctor(3);\n      newDst[0] = 1 / v[0];\n      newDst[1] = 1 / v[1];\n      newDst[2] = 1 / v[2];\n      return newDst;\n    }\n    /**\n     * Invert a vector. (same as inverse)\n     * @param v - The vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The inverted vector.\n     */\n    var invert = inverse;\n    /**\n     * Computes the cross product of two vectors; assumes both vectors have\n     * three entries.\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The vector of a cross b.\n     */\n    function cross(a, b, dst) {\n      var newDst = dst != null ? dst : new Ctor(3);\n      var t1 = a[2] * b[0] - a[0] * b[2];\n      var t2 = a[0] * b[1] - a[1] * b[0];\n      newDst[0] = a[1] * b[2] - a[2] * b[1];\n      newDst[1] = t1;\n      newDst[2] = t2;\n      return newDst;\n    }\n    /**\n     * Computes the dot product of two vectors; assumes both vectors have\n     * three entries.\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @returns dot product\n     */\n    function dot(a, b) {\n      return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n    }\n    /**\n     * Computes the length of vector\n     * @param v - vector.\n     * @returns length of vector.\n     */\n    function length(v) {\n      var v0 = v[0];\n      var v1 = v[1];\n      var v2 = v[2];\n      return Math.sqrt(v0 * v0 + v1 * v1 + v2 * v2);\n    }\n    /**\n     * Computes the length of vector (same as length)\n     * @param v - vector.\n     * @returns length of vector.\n     */\n    var len = length;\n    /**\n     * Computes the square of the length of vector\n     * @param v - vector.\n     * @returns square of the length of vector.\n     */\n    function lengthSq(v) {\n      var v0 = v[0];\n      var v1 = v[1];\n      var v2 = v[2];\n      return v0 * v0 + v1 * v1 + v2 * v2;\n    }\n    /**\n     * Computes the square of the length of vector (same as lengthSq)\n     * @param v - vector.\n     * @returns square of the length of vector.\n     */\n    var lenSq = lengthSq;\n    /**\n     * Computes the distance between 2 points\n     * @param a - vector.\n     * @param b - vector.\n     * @returns distance between a and b\n     */\n    function distance(a, b) {\n      var dx = a[0] - b[0];\n      var dy = a[1] - b[1];\n      var dz = a[2] - b[2];\n      return Math.sqrt(dx * dx + dy * dy + dz * dz);\n    }\n    /**\n     * Computes the distance between 2 points (same as distance)\n     * @param a - vector.\n     * @param b - vector.\n     * @returns distance between a and b\n     */\n    var dist = distance;\n    /**\n     * Computes the square of the distance between 2 points\n     * @param a - vector.\n     * @param b - vector.\n     * @returns square of the distance between a and b\n     */\n    function distanceSq(a, b) {\n      var dx = a[0] - b[0];\n      var dy = a[1] - b[1];\n      var dz = a[2] - b[2];\n      return dx * dx + dy * dy + dz * dz;\n    }\n    /**\n     * Computes the square of the distance between 2 points (same as distanceSq)\n     * @param a - vector.\n     * @param b - vector.\n     * @returns square of the distance between a and b\n     */\n    var distSq = distanceSq;\n    /**\n     * Divides a vector by its Euclidean length and returns the quotient.\n     * @param v - The vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The normalized vector.\n     */\n    function normalize(v, dst) {\n      var newDst = dst != null ? dst : new Ctor(3);\n      var v0 = v[0];\n      var v1 = v[1];\n      var v2 = v[2];\n      var len = Math.sqrt(v0 * v0 + v1 * v1 + v2 * v2);\n      if (len > 0.00001) {\n        newDst[0] = v0 / len;\n        newDst[1] = v1 / len;\n        newDst[2] = v2 / len;\n      } else {\n        newDst[0] = 0;\n        newDst[1] = 0;\n        newDst[2] = 0;\n      }\n      return newDst;\n    }\n    /**\n     * Negates a vector.\n     * @param v - The vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns -v.\n     */\n    function negate(v, dst) {\n      var newDst = dst != null ? dst : new Ctor(3);\n      newDst[0] = -v[0];\n      newDst[1] = -v[1];\n      newDst[2] = -v[2];\n      return newDst;\n    }\n    /**\n     * Copies a vector. (same as {@link vec3.clone})\n     * Also see {@link vec3.create} and {@link vec3.set}\n     * @param v - The vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A copy of v.\n     */\n    function copy(v, dst) {\n      var newDst = dst != null ? dst : new Ctor(3);\n      newDst[0] = v[0];\n      newDst[1] = v[1];\n      newDst[2] = v[2];\n      return newDst;\n    }\n    /**\n     * Clones a vector. (same as {@link vec3.copy})\n     * Also see {@link vec3.create} and {@link vec3.set}\n     * @param v - The vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A copy of v.\n     */\n    var clone = copy;\n    /**\n     * Multiplies a vector by another vector (component-wise); assumes a and\n     * b have the same length.\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The vector of products of entries of a and b.\n     */\n    function multiply(a, b, dst) {\n      var newDst = dst != null ? dst : new Ctor(3);\n      newDst[0] = a[0] * b[0];\n      newDst[1] = a[1] * b[1];\n      newDst[2] = a[2] * b[2];\n      return newDst;\n    }\n    /**\n     * Multiplies a vector by another vector (component-wise); assumes a and\n     * b have the same length. (same as mul)\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The vector of products of entries of a and b.\n     */\n    var mul = multiply;\n    /**\n     * Divides a vector by another vector (component-wise); assumes a and\n     * b have the same length.\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The vector of quotients of entries of a and b.\n     */\n    function divide(a, b, dst) {\n      var newDst = dst != null ? dst : new Ctor(3);\n      newDst[0] = a[0] / b[0];\n      newDst[1] = a[1] / b[1];\n      newDst[2] = a[2] / b[2];\n      return newDst;\n    }\n    /**\n     * Divides a vector by another vector (component-wise); assumes a and\n     * b have the same length. (same as divide)\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The vector of quotients of entries of a and b.\n     */\n    var div = divide;\n    /**\n     * Creates a random vector\n     * @param scale - Default 1\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The random vector.\n     */\n    function random() {\n      var scale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n      var dst = arguments.length > 1 ? arguments[1] : undefined;\n      var newDst = dst != null ? dst : new Ctor(3);\n      var angle = Math.random() * 2 * Math.PI;\n      var z = Math.random() * 2 - 1;\n      var zScale = Math.sqrt(1 - z * z) * scale;\n      newDst[0] = Math.cos(angle) * zScale;\n      newDst[1] = Math.sin(angle) * zScale;\n      newDst[2] = z * scale;\n      return newDst;\n    }\n    /**\n     * Zero's a vector\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The zeroed vector.\n     */\n    function zero(dst) {\n      var newDst = dst != null ? dst : new Ctor(3);\n      newDst[0] = 0;\n      newDst[1] = 0;\n      newDst[2] = 0;\n      return newDst;\n    }\n    /**\n     * transform vec3 by 4x4 matrix\n     * @param v - the vector\n     * @param m - The matrix.\n     * @param dst - optional vec3 to store result. If not passed a new one is created.\n     * @returns the transformed vector\n     */\n    function transformMat4(v, m, dst) {\n      var newDst = dst != null ? dst : new Ctor(3);\n      var x = v[0];\n      var y = v[1];\n      var z = v[2];\n      var w = m[3] * x + m[7] * y + m[11] * z + m[15] || 1;\n      newDst[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;\n      newDst[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;\n      newDst[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;\n      return newDst;\n    }\n    /**\n     * Transform vec3 by upper 3x3 matrix inside 4x4 matrix.\n     * @param v - The direction.\n     * @param m - The matrix.\n     * @param dst - optional vec3 to store result. If not passed a new one is created.\n     * @returns The transformed vector.\n     */\n    function transformMat4Upper3x3(v, m, dst) {\n      var newDst = dst != null ? dst : new Ctor(3);\n      var v0 = v[0];\n      var v1 = v[1];\n      var v2 = v[2];\n      newDst[0] = v0 * m[0 * 4 + 0] + v1 * m[1 * 4 + 0] + v2 * m[2 * 4 + 0];\n      newDst[1] = v0 * m[0 * 4 + 1] + v1 * m[1 * 4 + 1] + v2 * m[2 * 4 + 1];\n      newDst[2] = v0 * m[0 * 4 + 2] + v1 * m[1 * 4 + 2] + v2 * m[2 * 4 + 2];\n      return newDst;\n    }\n    /**\n     * Transforms vec3 by 3x3 matrix\n     *\n     * @param v - the vector\n     * @param m - The matrix.\n     * @param dst - optional vec3 to store result. If not passed a new one is created.\n     * @returns the transformed vector\n     */\n    function transformMat3(v, m, dst) {\n      var newDst = dst != null ? dst : new Ctor(3);\n      var x = v[0];\n      var y = v[1];\n      var z = v[2];\n      newDst[0] = x * m[0] + y * m[4] + z * m[8];\n      newDst[1] = x * m[1] + y * m[5] + z * m[9];\n      newDst[2] = x * m[2] + y * m[6] + z * m[10];\n      return newDst;\n    }\n    /**\n     * Transforms vec3 by Quaternion\n     * @param v - the vector to transform\n     * @param q - the quaternion to transform by\n     * @param dst - optional vec3 to store result. If not passed a new one is created.\n     * @returns the transformed\n     */\n    function transformQuat(v, q, dst) {\n      var newDst = dst != null ? dst : new Ctor(3);\n      var qx = q[0];\n      var qy = q[1];\n      var qz = q[2];\n      var w2 = q[3] * 2;\n      var x = v[0];\n      var y = v[1];\n      var z = v[2];\n      var uvX = qy * z - qz * y;\n      var uvY = qz * x - qx * z;\n      var uvZ = qx * y - qy * x;\n      newDst[0] = x + uvX * w2 + (qy * uvZ - qz * uvY) * 2;\n      newDst[1] = y + uvY * w2 + (qz * uvX - qx * uvZ) * 2;\n      newDst[2] = z + uvZ * w2 + (qx * uvY - qy * uvX) * 2;\n      return newDst;\n    }\n    /**\n     * Returns the translation component of a 4-by-4 matrix as a vector with 3\n     * entries.\n     * @param m - The matrix.\n     * @param dst - vector to hold result. If not passed a new one is created.\n     * @returns The translation component of m.\n     */\n    function getTranslation(m, dst) {\n      var newDst = dst != null ? dst : new Ctor(3);\n      newDst[0] = m[12];\n      newDst[1] = m[13];\n      newDst[2] = m[14];\n      return newDst;\n    }\n    /**\n     * Returns an axis of a 4x4 matrix as a vector with 3 entries\n     * @param m - The matrix.\n     * @param axis - The axis 0 = x, 1 = y, 2 = z;\n     * @returns The axis component of m.\n     */\n    function getAxis(m, axis, dst) {\n      var newDst = dst != null ? dst : new Ctor(3);\n      var off = axis * 4;\n      newDst[0] = m[off + 0];\n      newDst[1] = m[off + 1];\n      newDst[2] = m[off + 2];\n      return newDst;\n    }\n    /**\n     * Returns the scaling component of the matrix\n     * @param m - The Matrix\n     * @param dst - The vector to set. If not passed a new one is created.\n     */\n    function getScaling(m, dst) {\n      var newDst = dst != null ? dst : new Ctor(3);\n      var xx = m[0];\n      var xy = m[1];\n      var xz = m[2];\n      var yx = m[4];\n      var yy = m[5];\n      var yz = m[6];\n      var zx = m[8];\n      var zy = m[9];\n      var zz = m[10];\n      newDst[0] = Math.sqrt(xx * xx + xy * xy + xz * xz);\n      newDst[1] = Math.sqrt(yx * yx + yy * yy + yz * yz);\n      newDst[2] = Math.sqrt(zx * zx + zy * zy + zz * zz);\n      return newDst;\n    }\n    /**\n     * Rotate a 3D vector around the x-axis\n     *\n     * @param {ReadonlyVec3} a The vec3 point to rotate\n     * @param {ReadonlyVec3} b The origin of the rotation\n     * @param {Number} rad The angle of rotation in radians\n     * @param dst - The vector to set. If not passed a new one is created.\n     * @returns the rotated vector\n     */\n    function rotateX(a, b, rad, dst) {\n      var newDst = dst != null ? dst : new Ctor(3);\n      var p = [];\n      var r = [];\n      //Translate point to the origin\n      p[0] = a[0] - b[0];\n      p[1] = a[1] - b[1];\n      p[2] = a[2] - b[2];\n      //perform rotation\n      r[0] = p[0];\n      r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);\n      r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad);\n      //translate to correct position\n      newDst[0] = r[0] + b[0];\n      newDst[1] = r[1] + b[1];\n      newDst[2] = r[2] + b[2];\n      return newDst;\n    }\n    /**\n     * Rotate a 3D vector around the y-axis\n     *\n     * @param {ReadonlyVec3} a The vec3 point to rotate\n     * @param {ReadonlyVec3} b The origin of the rotation\n     * @param {Number} rad The angle of rotation in radians\n     * @param dst - The vector to set. If not passed a new one is created.\n     * @returns the rotated vector\n     */\n    function rotateY(a, b, rad, dst) {\n      var newDst = dst != null ? dst : new Ctor(3);\n      var p = [];\n      var r = [];\n      // translate point to the origin\n      p[0] = a[0] - b[0];\n      p[1] = a[1] - b[1];\n      p[2] = a[2] - b[2];\n      // perform rotation\n      r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);\n      r[1] = p[1];\n      r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad);\n      // translate to correct position\n      newDst[0] = r[0] + b[0];\n      newDst[1] = r[1] + b[1];\n      newDst[2] = r[2] + b[2];\n      return newDst;\n    }\n    /**\n     * Rotate a 3D vector around the z-axis\n     *\n     * @param {ReadonlyVec3} a The vec3 point to rotate\n     * @param {ReadonlyVec3} b The origin of the rotation\n     * @param {Number} rad The angle of rotation in radians\n     * @param dst - The vector to set. If not passed a new one is created.\n     * @returns {vec3} out\n     */\n    function rotateZ(a, b, rad, dst) {\n      var newDst = dst != null ? dst : new Ctor(3);\n      var p = [];\n      var r = [];\n      // translate point to the origin\n      p[0] = a[0] - b[0];\n      p[1] = a[1] - b[1];\n      p[2] = a[2] - b[2];\n      // perform rotation\n      r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);\n      r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);\n      r[2] = p[2];\n      // translate to correct position\n      newDst[0] = r[0] + b[0];\n      newDst[1] = r[1] + b[1];\n      newDst[2] = r[2] + b[2];\n      return newDst;\n    }\n    /**\n     * Treat a 3D vector as a direction and set it's length\n     *\n     * @param a The vec3 to lengthen\n     * @param len The length of the resulting vector\n     * @returns The lengthened vector\n     */\n    function setLength(a, len, dst) {\n      var newDst = dst != null ? dst : new Ctor(3);\n      normalize(a, newDst);\n      return mulScalar(newDst, len, newDst);\n    }\n    /**\n     * Ensure a vector is not longer than a max length\n     *\n     * @param a The vec3 to limit\n     * @param maxLen The longest length of the resulting vector\n     * @returns The vector, shortened to maxLen if it's too long\n     */\n    function truncate(a, maxLen, dst) {\n      var newDst = dst != null ? dst : new Ctor(3);\n      if (length(a) > maxLen) {\n        return setLength(a, maxLen, newDst);\n      }\n      return copy(a, newDst);\n    }\n    /**\n     * Return the vector exactly between 2 endpoint vectors\n     *\n     * @param a Endpoint 1\n     * @param b Endpoint 2\n     * @returns The vector exactly residing between endpoints 1 and 2\n     */\n    function midpoint(a, b, dst) {\n      var newDst = dst != null ? dst : new Ctor(3);\n      return lerp(a, b, 0.5, newDst);\n    }\n    return {\n      create: create,\n      fromValues: fromValues,\n      set: set,\n      ceil: ceil,\n      floor: floor,\n      round: round,\n      clamp: clamp,\n      add: add,\n      addScaled: addScaled,\n      angle: angle,\n      subtract: subtract,\n      sub: sub,\n      equalsApproximately: equalsApproximately,\n      equals: equals,\n      lerp: lerp,\n      lerpV: lerpV,\n      max: max,\n      min: min,\n      mulScalar: mulScalar,\n      scale: scale,\n      divScalar: divScalar,\n      inverse: inverse,\n      invert: invert,\n      cross: cross,\n      dot: dot,\n      length: length,\n      len: len,\n      lengthSq: lengthSq,\n      lenSq: lenSq,\n      distance: distance,\n      dist: dist,\n      distanceSq: distanceSq,\n      distSq: distSq,\n      normalize: normalize,\n      negate: negate,\n      copy: copy,\n      clone: clone,\n      multiply: multiply,\n      mul: mul,\n      divide: divide,\n      div: div,\n      random: random,\n      zero: zero,\n      transformMat4: transformMat4,\n      transformMat4Upper3x3: transformMat4Upper3x3,\n      transformMat3: transformMat3,\n      transformQuat: transformQuat,\n      getTranslation: getTranslation,\n      getAxis: getAxis,\n      getScaling: getScaling,\n      rotateX: rotateX,\n      rotateY: rotateY,\n      rotateZ: rotateZ,\n      setLength: setLength,\n      truncate: truncate,\n      midpoint: midpoint\n    };\n  }\n  var cache$4 = new Map();\n  function getAPI$4(Ctor) {\n    var api = cache$4.get(Ctor);\n    if (!api) {\n      api = getAPIImpl$4(Ctor);\n      cache$4.set(Ctor, api);\n    }\n    return api;\n  }\n\n  /*\n   * Copyright 2022 Gregg Tavares\n   *\n   * Permission is hereby granted, free of charge, to any person obtaining a\n   * copy of this software and associated documentation files (the \"Software\"),\n   * to deal in the Software without restriction, including without limitation\n   * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n   * and/or sell copies of the Software, and to permit persons to whom the\n   * Software is furnished to do so, subject to the following conditions:\n   *\n   * The above copyright notice and this permission notice shall be included in\n   * all copies or substantial portions of the Software.\n   *\n   * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n   * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n   * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n   * DEALINGS IN THE SOFTWARE.\n   */\n  /**\n   * Generates a typed API for Mat3\n   * */\n  function getAPIImpl$3(Ctor) {\n    var vec2 = getAPI$5(Ctor);\n    var vec3 = getAPI$4(Ctor);\n    /**\n     * Create a Mat3 from values\n     *\n     * Note: Since passing in a raw JavaScript array\n     * is valid in all circumstances, if you want to\n     * force a JavaScript array into a Mat3's specified type\n     * it would be faster to use\n     *\n     * ```\n     * const m = mat3.clone(someJSArray);\n     * ```\n     *\n     * @param v0 - value for element 0\n     * @param v1 - value for element 1\n     * @param v2 - value for element 2\n     * @param v3 - value for element 3\n     * @param v4 - value for element 4\n     * @param v5 - value for element 5\n     * @param v6 - value for element 6\n     * @param v7 - value for element 7\n     * @param v8 - value for element 8\n     * @returns matrix created from values.\n     */\n    function create(v0, v1, v2, v3, v4, v5, v6, v7, v8) {\n      var newDst = new Ctor(12);\n      // to make the array homogenous\n      newDst[3] = 0;\n      newDst[7] = 0;\n      newDst[11] = 0;\n      if (v0 !== undefined) {\n        newDst[0] = v0;\n        if (v1 !== undefined) {\n          newDst[1] = v1;\n          if (v2 !== undefined) {\n            newDst[2] = v2;\n            if (v3 !== undefined) {\n              newDst[4] = v3;\n              if (v4 !== undefined) {\n                newDst[5] = v4;\n                if (v5 !== undefined) {\n                  newDst[6] = v5;\n                  if (v6 !== undefined) {\n                    newDst[8] = v6;\n                    if (v7 !== undefined) {\n                      newDst[9] = v7;\n                      if (v8 !== undefined) {\n                        newDst[10] = v8;\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      return newDst;\n    }\n    /**\n     * Sets the values of a Mat3\n     * Also see {@link mat3.create} and {@link mat3.copy}\n     *\n     * @param v0 - value for element 0\n     * @param v1 - value for element 1\n     * @param v2 - value for element 2\n     * @param v3 - value for element 3\n     * @param v4 - value for element 4\n     * @param v5 - value for element 5\n     * @param v6 - value for element 6\n     * @param v7 - value for element 7\n     * @param v8 - value for element 8\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns Mat3 set from values.\n     */\n    function set(v0, v1, v2, v3, v4, v5, v6, v7, v8, dst) {\n      var newDst = dst != null ? dst : new Ctor(12);\n      newDst[0] = v0;\n      newDst[1] = v1;\n      newDst[2] = v2;\n      newDst[3] = 0;\n      newDst[4] = v3;\n      newDst[5] = v4;\n      newDst[6] = v5;\n      newDst[7] = 0;\n      newDst[8] = v6;\n      newDst[9] = v7;\n      newDst[10] = v8;\n      newDst[11] = 0;\n      return newDst;\n    }\n    /**\n     * Creates a Mat3 from the upper left 3x3 part of a Mat4\n     * @param m4 - source matrix\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns Mat3 made from m4\n     */\n    function fromMat4(m4, dst) {\n      var newDst = dst != null ? dst : new Ctor(12);\n      newDst[0] = m4[0];\n      newDst[1] = m4[1];\n      newDst[2] = m4[2];\n      newDst[3] = 0;\n      newDst[4] = m4[4];\n      newDst[5] = m4[5];\n      newDst[6] = m4[6];\n      newDst[7] = 0;\n      newDst[8] = m4[8];\n      newDst[9] = m4[9];\n      newDst[10] = m4[10];\n      newDst[11] = 0;\n      return newDst;\n    }\n    /**\n     * Creates a Mat3 rotation matrix from a quaternion\n     * @param q - quaternion to create matrix from\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns Mat3 made from q\n     */\n    function fromQuat(q, dst) {\n      var newDst = dst != null ? dst : new Ctor(12);\n      var x = q[0];\n      var y = q[1];\n      var z = q[2];\n      var w = q[3];\n      var x2 = x + x;\n      var y2 = y + y;\n      var z2 = z + z;\n      var xx = x * x2;\n      var yx = y * x2;\n      var yy = y * y2;\n      var zx = z * x2;\n      var zy = z * y2;\n      var zz = z * z2;\n      var wx = w * x2;\n      var wy = w * y2;\n      var wz = w * z2;\n      newDst[0] = 1 - yy - zz;\n      newDst[1] = yx + wz;\n      newDst[2] = zx - wy;\n      newDst[3] = 0;\n      newDst[4] = yx - wz;\n      newDst[5] = 1 - xx - zz;\n      newDst[6] = zy + wx;\n      newDst[7] = 0;\n      newDst[8] = zx + wy;\n      newDst[9] = zy - wx;\n      newDst[10] = 1 - xx - yy;\n      newDst[11] = 0;\n      return newDst;\n    }\n    /**\n     * Negates a matrix.\n     * @param m - The matrix.\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns -m.\n     */\n    function negate(m, dst) {\n      var newDst = dst != null ? dst : new Ctor(12);\n      newDst[0] = -m[0];\n      newDst[1] = -m[1];\n      newDst[2] = -m[2];\n      newDst[4] = -m[4];\n      newDst[5] = -m[5];\n      newDst[6] = -m[6];\n      newDst[8] = -m[8];\n      newDst[9] = -m[9];\n      newDst[10] = -m[10];\n      return newDst;\n    }\n    /**\n     * Copies a matrix. (same as {@link mat3.clone})\n     * Also see {@link mat3.create} and {@link mat3.set}\n     * @param m - The matrix.\n     * @param dst - The matrix. If not passed a new one is created.\n     * @returns A copy of m.\n     */\n    function copy(m, dst) {\n      var newDst = dst != null ? dst : new Ctor(12);\n      newDst[0] = m[0];\n      newDst[1] = m[1];\n      newDst[2] = m[2];\n      newDst[4] = m[4];\n      newDst[5] = m[5];\n      newDst[6] = m[6];\n      newDst[8] = m[8];\n      newDst[9] = m[9];\n      newDst[10] = m[10];\n      return newDst;\n    }\n    /**\n     * Copies a matrix (same as {@link mat3.copy})\n     * Also see {@link mat3.create} and {@link mat3.set}\n     * @param m - The matrix.\n     * @param dst - The matrix. If not passed a new one is created.\n     * @returns A copy of m.\n     */\n    var clone = copy;\n    /**\n     * Check if 2 matrices are approximately equal\n     * @param a Operand matrix.\n     * @param b Operand matrix.\n     * @returns true if matrices are approximately equal\n     */\n    function equalsApproximately(a, b) {\n      return Math.abs(a[0] - b[0]) < EPSILON && Math.abs(a[1] - b[1]) < EPSILON && Math.abs(a[2] - b[2]) < EPSILON && Math.abs(a[4] - b[4]) < EPSILON && Math.abs(a[5] - b[5]) < EPSILON && Math.abs(a[6] - b[6]) < EPSILON && Math.abs(a[8] - b[8]) < EPSILON && Math.abs(a[9] - b[9]) < EPSILON && Math.abs(a[10] - b[10]) < EPSILON;\n    }\n    /**\n     * Check if 2 matrices are exactly equal\n     * @param a Operand matrix.\n     * @param b Operand matrix.\n     * @returns true if matrices are exactly equal\n     */\n    function equals(a, b) {\n      return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10];\n    }\n    /**\n     * Creates a 3-by-3 identity matrix.\n     *\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns A 3-by-3 identity matrix.\n     */\n    function identity(dst) {\n      var newDst = dst != null ? dst : new Ctor(12);\n      newDst[0] = 1;\n      newDst[1] = 0;\n      newDst[2] = 0;\n      newDst[4] = 0;\n      newDst[5] = 1;\n      newDst[6] = 0;\n      newDst[8] = 0;\n      newDst[9] = 0;\n      newDst[10] = 1;\n      return newDst;\n    }\n    /**\n     * Takes the transpose of a matrix.\n     * @param m - The matrix.\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The transpose of m.\n     */\n    function transpose(m, dst) {\n      var newDst = dst != null ? dst : new Ctor(12);\n      if (newDst === m) {\n        var t;\n        // 0 1 2\n        // 4 5 6\n        // 8 9 10\n        t = m[1];\n        m[1] = m[4];\n        m[4] = t;\n        t = m[2];\n        m[2] = m[8];\n        m[8] = t;\n        t = m[6];\n        m[6] = m[9];\n        m[9] = t;\n        return newDst;\n      }\n      var m00 = m[0 * 4 + 0];\n      var m01 = m[0 * 4 + 1];\n      var m02 = m[0 * 4 + 2];\n      var m10 = m[1 * 4 + 0];\n      var m11 = m[1 * 4 + 1];\n      var m12 = m[1 * 4 + 2];\n      var m20 = m[2 * 4 + 0];\n      var m21 = m[2 * 4 + 1];\n      var m22 = m[2 * 4 + 2];\n      newDst[0] = m00;\n      newDst[1] = m10;\n      newDst[2] = m20;\n      newDst[4] = m01;\n      newDst[5] = m11;\n      newDst[6] = m21;\n      newDst[8] = m02;\n      newDst[9] = m12;\n      newDst[10] = m22;\n      return newDst;\n    }\n    /**\n     * Computes the inverse of a 3-by-3 matrix.\n     * @param m - The matrix.\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The inverse of m.\n     */\n    function inverse(m, dst) {\n      var newDst = dst != null ? dst : new Ctor(12);\n      var m00 = m[0 * 4 + 0];\n      var m01 = m[0 * 4 + 1];\n      var m02 = m[0 * 4 + 2];\n      var m10 = m[1 * 4 + 0];\n      var m11 = m[1 * 4 + 1];\n      var m12 = m[1 * 4 + 2];\n      var m20 = m[2 * 4 + 0];\n      var m21 = m[2 * 4 + 1];\n      var m22 = m[2 * 4 + 2];\n      var b01 = m22 * m11 - m12 * m21;\n      var b11 = -m22 * m10 + m12 * m20;\n      var b21 = m21 * m10 - m11 * m20;\n      var invDet = 1 / (m00 * b01 + m01 * b11 + m02 * b21);\n      newDst[0] = b01 * invDet;\n      newDst[1] = (-m22 * m01 + m02 * m21) * invDet;\n      newDst[2] = (m12 * m01 - m02 * m11) * invDet;\n      newDst[4] = b11 * invDet;\n      newDst[5] = (m22 * m00 - m02 * m20) * invDet;\n      newDst[6] = (-m12 * m00 + m02 * m10) * invDet;\n      newDst[8] = b21 * invDet;\n      newDst[9] = (-m21 * m00 + m01 * m20) * invDet;\n      newDst[10] = (m11 * m00 - m01 * m10) * invDet;\n      return newDst;\n    }\n    /**\n     * Compute the determinant of a matrix\n     * @param m - the matrix\n     * @returns the determinant\n     */\n    function determinant(m) {\n      var m00 = m[0 * 4 + 0];\n      var m01 = m[0 * 4 + 1];\n      var m02 = m[0 * 4 + 2];\n      var m10 = m[1 * 4 + 0];\n      var m11 = m[1 * 4 + 1];\n      var m12 = m[1 * 4 + 2];\n      var m20 = m[2 * 4 + 0];\n      var m21 = m[2 * 4 + 1];\n      var m22 = m[2 * 4 + 2];\n      return m00 * (m11 * m22 - m21 * m12) - m10 * (m01 * m22 - m21 * m02) + m20 * (m01 * m12 - m11 * m02);\n    }\n    /**\n     * Computes the inverse of a 3-by-3 matrix. (same as inverse)\n     * @param m - The matrix.\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The inverse of m.\n     */\n    var invert = inverse;\n    /**\n     * Multiplies two 3-by-3 matrices with a on the left and b on the right\n     * @param a - The matrix on the left.\n     * @param b - The matrix on the right.\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The matrix product of a and b.\n     */\n    function multiply(a, b, dst) {\n      var newDst = dst != null ? dst : new Ctor(12);\n      var a00 = a[0];\n      var a01 = a[1];\n      var a02 = a[2];\n      var a10 = a[4 + 0];\n      var a11 = a[4 + 1];\n      var a12 = a[4 + 2];\n      var a20 = a[8 + 0];\n      var a21 = a[8 + 1];\n      var a22 = a[8 + 2];\n      var b00 = b[0];\n      var b01 = b[1];\n      var b02 = b[2];\n      var b10 = b[4 + 0];\n      var b11 = b[4 + 1];\n      var b12 = b[4 + 2];\n      var b20 = b[8 + 0];\n      var b21 = b[8 + 1];\n      var b22 = b[8 + 2];\n      newDst[0] = a00 * b00 + a10 * b01 + a20 * b02;\n      newDst[1] = a01 * b00 + a11 * b01 + a21 * b02;\n      newDst[2] = a02 * b00 + a12 * b01 + a22 * b02;\n      newDst[4] = a00 * b10 + a10 * b11 + a20 * b12;\n      newDst[5] = a01 * b10 + a11 * b11 + a21 * b12;\n      newDst[6] = a02 * b10 + a12 * b11 + a22 * b12;\n      newDst[8] = a00 * b20 + a10 * b21 + a20 * b22;\n      newDst[9] = a01 * b20 + a11 * b21 + a21 * b22;\n      newDst[10] = a02 * b20 + a12 * b21 + a22 * b22;\n      return newDst;\n    }\n    /**\n     * Multiplies two 3-by-3 matrices with a on the left and b on the right (same as multiply)\n     * @param a - The matrix on the left.\n     * @param b - The matrix on the right.\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The matrix product of a and b.\n     */\n    var mul = multiply;\n    /**\n     * Sets the translation component of a 3-by-3 matrix to the given\n     * vector.\n     * @param a - The matrix.\n     * @param v - The vector.\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The matrix with translation set.\n     */\n    function setTranslation(a, v, dst) {\n      var newDst = dst != null ? dst : identity();\n      if (a !== newDst) {\n        newDst[0] = a[0];\n        newDst[1] = a[1];\n        newDst[2] = a[2];\n        newDst[4] = a[4];\n        newDst[5] = a[5];\n        newDst[6] = a[6];\n      }\n      newDst[8] = v[0];\n      newDst[9] = v[1];\n      newDst[10] = 1;\n      return newDst;\n    }\n    /**\n     * Returns the translation component of a 3-by-3 matrix as a vector with 3\n     * entries.\n     * @param m - The matrix.\n     * @param dst - vector to hold result. If not passed a new one is created.\n     * @returns The translation component of m.\n     */\n    function getTranslation(m, dst) {\n      var newDst = dst != null ? dst : vec2.create();\n      newDst[0] = m[8];\n      newDst[1] = m[9];\n      return newDst;\n    }\n    /**\n     * Returns an axis of a 3x3 matrix as a vector with 2 entries\n     * @param m - The matrix.\n     * @param axis - The axis 0 = x, 1 = y,\n     * @returns The axis component of m.\n     */\n    function getAxis(m, axis, dst) {\n      var newDst = dst != null ? dst : vec2.create();\n      var off = axis * 4;\n      newDst[0] = m[off + 0];\n      newDst[1] = m[off + 1];\n      return newDst;\n    }\n    /**\n     * Sets an axis of a 3x3 matrix as a vector with 2 entries\n     * @param m - The matrix.\n     * @param v - the axis vector\n     * @param axis - The axis  0 = x, 1 = y;\n     * @param dst - The matrix to set. If not passed a new one is created.\n     * @returns The matrix with axis set.\n     */\n    function setAxis(m, v, axis, dst) {\n      var newDst = dst === m ? m : copy(m, dst);\n      var off = axis * 4;\n      newDst[off + 0] = v[0];\n      newDst[off + 1] = v[1];\n      return newDst;\n    }\n    /**\n     * Returns the \"2d\" scaling component of the matrix\n     * @param m - The Matrix\n     * @param dst - The vector to set. If not passed a new one is created.\n     */\n    function getScaling(m, dst) {\n      var newDst = dst != null ? dst : vec2.create();\n      var xx = m[0];\n      var xy = m[1];\n      var yx = m[4];\n      var yy = m[5];\n      newDst[0] = Math.sqrt(xx * xx + xy * xy);\n      newDst[1] = Math.sqrt(yx * yx + yy * yy);\n      return newDst;\n    }\n    /**\n     * Returns the \"3d\" scaling component of the matrix\n     * @param m - The Matrix\n     * @param dst - The vector to set. If not passed a new one is created.\n     */\n    function get3DScaling(m, dst) {\n      var newDst = dst != null ? dst : vec3.create();\n      var xx = m[0];\n      var xy = m[1];\n      var xz = m[2];\n      var yx = m[4];\n      var yy = m[5];\n      var yz = m[6];\n      var zx = m[8];\n      var zy = m[9];\n      var zz = m[10];\n      newDst[0] = Math.sqrt(xx * xx + xy * xy + xz * xz);\n      newDst[1] = Math.sqrt(yx * yx + yy * yy + yz * yz);\n      newDst[2] = Math.sqrt(zx * zx + zy * zy + zz * zz);\n      return newDst;\n    }\n    /**\n     * Creates a 3-by-3 matrix which translates by the given vector v.\n     * @param v - The vector by which to translate.\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The translation matrix.\n     */\n    function translation(v, dst) {\n      var newDst = dst != null ? dst : new Ctor(12);\n      newDst[0] = 1;\n      newDst[1] = 0;\n      newDst[2] = 0;\n      newDst[4] = 0;\n      newDst[5] = 1;\n      newDst[6] = 0;\n      newDst[8] = v[0];\n      newDst[9] = v[1];\n      newDst[10] = 1;\n      return newDst;\n    }\n    /**\n     * Translates the given 3-by-3 matrix by the given vector v.\n     * @param m - The matrix.\n     * @param v - The vector by which to translate.\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The translated matrix.\n     */\n    function translate(m, v, dst) {\n      var newDst = dst != null ? dst : new Ctor(12);\n      var v0 = v[0];\n      var v1 = v[1];\n      var m00 = m[0];\n      var m01 = m[1];\n      var m02 = m[2];\n      var m10 = m[1 * 4 + 0];\n      var m11 = m[1 * 4 + 1];\n      var m12 = m[1 * 4 + 2];\n      var m20 = m[2 * 4 + 0];\n      var m21 = m[2 * 4 + 1];\n      var m22 = m[2 * 4 + 2];\n      if (m !== newDst) {\n        newDst[0] = m00;\n        newDst[1] = m01;\n        newDst[2] = m02;\n        newDst[4] = m10;\n        newDst[5] = m11;\n        newDst[6] = m12;\n      }\n      newDst[8] = m00 * v0 + m10 * v1 + m20;\n      newDst[9] = m01 * v0 + m11 * v1 + m21;\n      newDst[10] = m02 * v0 + m12 * v1 + m22;\n      return newDst;\n    }\n    /**\n     * Creates a 3-by-3 matrix which rotates  by the given angle.\n     * @param angleInRadians - The angle by which to rotate (in radians).\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The rotation matrix.\n     */\n    function rotation(angleInRadians, dst) {\n      var newDst = dst != null ? dst : new Ctor(12);\n      var c = Math.cos(angleInRadians);\n      var s = Math.sin(angleInRadians);\n      newDst[0] = c;\n      newDst[1] = s;\n      newDst[2] = 0;\n      newDst[4] = -s;\n      newDst[5] = c;\n      newDst[6] = 0;\n      newDst[8] = 0;\n      newDst[9] = 0;\n      newDst[10] = 1;\n      return newDst;\n    }\n    /**\n     * Rotates the given 3-by-3 matrix  by the given angle.\n     * @param m - The matrix.\n     * @param angleInRadians - The angle by which to rotate (in radians).\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The rotated matrix.\n     */\n    function rotate(m, angleInRadians, dst) {\n      var newDst = dst != null ? dst : new Ctor(12);\n      var m00 = m[0 * 4 + 0];\n      var m01 = m[0 * 4 + 1];\n      var m02 = m[0 * 4 + 2];\n      var m10 = m[1 * 4 + 0];\n      var m11 = m[1 * 4 + 1];\n      var m12 = m[1 * 4 + 2];\n      var c = Math.cos(angleInRadians);\n      var s = Math.sin(angleInRadians);\n      newDst[0] = c * m00 + s * m10;\n      newDst[1] = c * m01 + s * m11;\n      newDst[2] = c * m02 + s * m12;\n      newDst[4] = c * m10 - s * m00;\n      newDst[5] = c * m11 - s * m01;\n      newDst[6] = c * m12 - s * m02;\n      if (m !== newDst) {\n        newDst[8] = m[8];\n        newDst[9] = m[9];\n        newDst[10] = m[10];\n      }\n      return newDst;\n    }\n    /**\n     * Creates a 3-by-3 matrix which rotates around the x-axis by the given angle.\n     * @param angleInRadians - The angle by which to rotate (in radians).\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The rotation matrix.\n     */\n    function rotationX(angleInRadians, dst) {\n      var newDst = dst != null ? dst : new Ctor(12);\n      var c = Math.cos(angleInRadians);\n      var s = Math.sin(angleInRadians);\n      newDst[0] = 1;\n      newDst[1] = 0;\n      newDst[2] = 0;\n      newDst[4] = 0;\n      newDst[5] = c;\n      newDst[6] = s;\n      newDst[8] = 0;\n      newDst[9] = -s;\n      newDst[10] = c;\n      return newDst;\n    }\n    /**\n     * Rotates the given 3-by-3 matrix around the x-axis by the given\n     * angle.\n     * @param m - The matrix.\n     * @param angleInRadians - The angle by which to rotate (in radians).\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The rotated matrix.\n     */\n    function rotateX(m, angleInRadians, dst) {\n      var newDst = dst != null ? dst : new Ctor(12);\n      var m10 = m[4];\n      var m11 = m[5];\n      var m12 = m[6];\n      var m20 = m[8];\n      var m21 = m[9];\n      var m22 = m[10];\n      var c = Math.cos(angleInRadians);\n      var s = Math.sin(angleInRadians);\n      newDst[4] = c * m10 + s * m20;\n      newDst[5] = c * m11 + s * m21;\n      newDst[6] = c * m12 + s * m22;\n      newDst[8] = c * m20 - s * m10;\n      newDst[9] = c * m21 - s * m11;\n      newDst[10] = c * m22 - s * m12;\n      if (m !== newDst) {\n        newDst[0] = m[0];\n        newDst[1] = m[1];\n        newDst[2] = m[2];\n      }\n      return newDst;\n    }\n    /**\n     * Creates a 3-by-3 matrix which rotates around the y-axis by the given angle.\n     * @param angleInRadians - The angle by which to rotate (in radians).\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The rotation matrix.\n     */\n    function rotationY(angleInRadians, dst) {\n      var newDst = dst != null ? dst : new Ctor(12);\n      var c = Math.cos(angleInRadians);\n      var s = Math.sin(angleInRadians);\n      newDst[0] = c;\n      newDst[1] = 0;\n      newDst[2] = -s;\n      newDst[4] = 0;\n      newDst[5] = 1;\n      newDst[6] = 0;\n      newDst[8] = s;\n      newDst[9] = 0;\n      newDst[10] = c;\n      return newDst;\n    }\n    /**\n     * Rotates the given 3-by-3 matrix around the y-axis by the given\n     * angle.\n     * @param m - The matrix.\n     * @param angleInRadians - The angle by which to rotate (in radians).\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The rotated matrix.\n     */\n    function rotateY(m, angleInRadians, dst) {\n      var newDst = dst != null ? dst : new Ctor(12);\n      var m00 = m[0 * 4 + 0];\n      var m01 = m[0 * 4 + 1];\n      var m02 = m[0 * 4 + 2];\n      var m20 = m[2 * 4 + 0];\n      var m21 = m[2 * 4 + 1];\n      var m22 = m[2 * 4 + 2];\n      var c = Math.cos(angleInRadians);\n      var s = Math.sin(angleInRadians);\n      newDst[0] = c * m00 - s * m20;\n      newDst[1] = c * m01 - s * m21;\n      newDst[2] = c * m02 - s * m22;\n      newDst[8] = c * m20 + s * m00;\n      newDst[9] = c * m21 + s * m01;\n      newDst[10] = c * m22 + s * m02;\n      if (m !== newDst) {\n        newDst[4] = m[4];\n        newDst[5] = m[5];\n        newDst[6] = m[6];\n      }\n      return newDst;\n    }\n    /**\n     * Creates a 3-by-3 matrix which rotates around the z-axis by the given angle.\n     * @param angleInRadians - The angle by which to rotate (in radians).\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The rotation matrix.\n     */\n    var rotationZ = rotation;\n    /**\n     * Rotates the given 3-by-3 matrix around the z-axis by the given\n     * angle.\n     * @param m - The matrix.\n     * @param angleInRadians - The angle by which to rotate (in radians).\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The rotated matrix.\n     */\n    var rotateZ = rotate;\n    /**\n     * Creates a 3-by-3 matrix which scales in each dimension by an amount given by\n     * the corresponding entry in the given vector; assumes the vector has two\n     * entries.\n     * @param v - A vector of\n     *     2 entries specifying the factor by which to scale in each dimension.\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The scaling matrix.\n     */\n    function scaling(v, dst) {\n      var newDst = dst != null ? dst : new Ctor(12);\n      newDst[0] = v[0];\n      newDst[1] = 0;\n      newDst[2] = 0;\n      newDst[4] = 0;\n      newDst[5] = v[1];\n      newDst[6] = 0;\n      newDst[8] = 0;\n      newDst[9] = 0;\n      newDst[10] = 1;\n      return newDst;\n    }\n    /**\n     * Scales the given 3-by-3 matrix in each dimension by an amount\n     * given by the corresponding entry in the given vector; assumes the vector has\n     * two entries.\n     * @param m - The matrix to be modified.\n     * @param v - A vector of 2 entries specifying the\n     *     factor by which to scale in each dimension.\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The scaled matrix.\n     */\n    function scale(m, v, dst) {\n      var newDst = dst != null ? dst : new Ctor(12);\n      var v0 = v[0];\n      var v1 = v[1];\n      newDst[0] = v0 * m[0 * 4 + 0];\n      newDst[1] = v0 * m[0 * 4 + 1];\n      newDst[2] = v0 * m[0 * 4 + 2];\n      newDst[4] = v1 * m[1 * 4 + 0];\n      newDst[5] = v1 * m[1 * 4 + 1];\n      newDst[6] = v1 * m[1 * 4 + 2];\n      if (m !== newDst) {\n        newDst[8] = m[8];\n        newDst[9] = m[9];\n        newDst[10] = m[10];\n      }\n      return newDst;\n    }\n    /**\n     * Creates a 3-by-3 matrix which scales in each dimension by an amount given by\n     * the corresponding entry in the given vector; assumes the vector has three\n     * entries.\n     * @param v - A vector of\n     *     3 entries specifying the factor by which to scale in each dimension.\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The scaling matrix.\n     */\n    function scaling3D(v, dst) {\n      var newDst = dst != null ? dst : new Ctor(12);\n      newDst[0] = v[0];\n      newDst[1] = 0;\n      newDst[2] = 0;\n      newDst[4] = 0;\n      newDst[5] = v[1];\n      newDst[6] = 0;\n      newDst[8] = 0;\n      newDst[9] = 0;\n      newDst[10] = v[2];\n      return newDst;\n    }\n    /**\n     * Scales the given 3-by-3 matrix in each dimension by an amount\n     * given by the corresponding entry in the given vector; assumes the vector has\n     * three entries.\n     * @param m - The matrix to be modified.\n     * @param v - A vector of 3 entries specifying the\n     *     factor by which to scale in each dimension.\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The scaled matrix.\n     */\n    function scale3D(m, v, dst) {\n      var newDst = dst != null ? dst : new Ctor(12);\n      var v0 = v[0];\n      var v1 = v[1];\n      var v2 = v[2];\n      newDst[0] = v0 * m[0 * 4 + 0];\n      newDst[1] = v0 * m[0 * 4 + 1];\n      newDst[2] = v0 * m[0 * 4 + 2];\n      newDst[4] = v1 * m[1 * 4 + 0];\n      newDst[5] = v1 * m[1 * 4 + 1];\n      newDst[6] = v1 * m[1 * 4 + 2];\n      newDst[8] = v2 * m[2 * 4 + 0];\n      newDst[9] = v2 * m[2 * 4 + 1];\n      newDst[10] = v2 * m[2 * 4 + 2];\n      return newDst;\n    }\n    /**\n     * Creates a 3-by-3 matrix which scales uniformly in the X and Y dimensions\n     * @param s - Amount to scale\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The scaling matrix.\n     */\n    function uniformScaling(s, dst) {\n      var newDst = dst != null ? dst : new Ctor(12);\n      newDst[0] = s;\n      newDst[1] = 0;\n      newDst[2] = 0;\n      newDst[4] = 0;\n      newDst[5] = s;\n      newDst[6] = 0;\n      newDst[8] = 0;\n      newDst[9] = 0;\n      newDst[10] = 1;\n      return newDst;\n    }\n    /**\n     * Scales the given 3-by-3 matrix in the X and Y dimension by an amount\n     * given.\n     * @param m - The matrix to be modified.\n     * @param s - Amount to scale.\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The scaled matrix.\n     */\n    function uniformScale(m, s, dst) {\n      var newDst = dst != null ? dst : new Ctor(12);\n      newDst[0] = s * m[0 * 4 + 0];\n      newDst[1] = s * m[0 * 4 + 1];\n      newDst[2] = s * m[0 * 4 + 2];\n      newDst[4] = s * m[1 * 4 + 0];\n      newDst[5] = s * m[1 * 4 + 1];\n      newDst[6] = s * m[1 * 4 + 2];\n      if (m !== newDst) {\n        newDst[8] = m[8];\n        newDst[9] = m[9];\n        newDst[10] = m[10];\n      }\n      return newDst;\n    }\n    /**\n     * Creates a 3-by-3 matrix which scales uniformly in each dimension\n     * @param s - Amount to scale\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The scaling matrix.\n     */\n    function uniformScaling3D(s, dst) {\n      var newDst = dst != null ? dst : new Ctor(12);\n      newDst[0] = s;\n      newDst[1] = 0;\n      newDst[2] = 0;\n      newDst[4] = 0;\n      newDst[5] = s;\n      newDst[6] = 0;\n      newDst[8] = 0;\n      newDst[9] = 0;\n      newDst[10] = s;\n      return newDst;\n    }\n    /**\n     * Scales the given 3-by-3 matrix in each dimension by an amount\n     * given.\n     * @param m - The matrix to be modified.\n     * @param s - Amount to scale.\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The scaled matrix.\n     */\n    function uniformScale3D(m, s, dst) {\n      var newDst = dst != null ? dst : new Ctor(12);\n      newDst[0] = s * m[0 * 4 + 0];\n      newDst[1] = s * m[0 * 4 + 1];\n      newDst[2] = s * m[0 * 4 + 2];\n      newDst[4] = s * m[1 * 4 + 0];\n      newDst[5] = s * m[1 * 4 + 1];\n      newDst[6] = s * m[1 * 4 + 2];\n      newDst[8] = s * m[2 * 4 + 0];\n      newDst[9] = s * m[2 * 4 + 1];\n      newDst[10] = s * m[2 * 4 + 2];\n      return newDst;\n    }\n    return {\n      clone: clone,\n      create: create,\n      set: set,\n      fromMat4: fromMat4,\n      fromQuat: fromQuat,\n      negate: negate,\n      copy: copy,\n      equalsApproximately: equalsApproximately,\n      equals: equals,\n      identity: identity,\n      transpose: transpose,\n      inverse: inverse,\n      invert: invert,\n      determinant: determinant,\n      mul: mul,\n      multiply: multiply,\n      setTranslation: setTranslation,\n      getTranslation: getTranslation,\n      getAxis: getAxis,\n      setAxis: setAxis,\n      getScaling: getScaling,\n      get3DScaling: get3DScaling,\n      translation: translation,\n      translate: translate,\n      rotation: rotation,\n      rotate: rotate,\n      rotationX: rotationX,\n      rotateX: rotateX,\n      rotationY: rotationY,\n      rotateY: rotateY,\n      rotationZ: rotationZ,\n      rotateZ: rotateZ,\n      scaling: scaling,\n      scale: scale,\n      uniformScaling: uniformScaling,\n      uniformScale: uniformScale,\n      scaling3D: scaling3D,\n      scale3D: scale3D,\n      uniformScaling3D: uniformScaling3D,\n      uniformScale3D: uniformScale3D\n    };\n  }\n  var cache$3 = new Map();\n  function getAPI$3(Ctor) {\n    var api = cache$3.get(Ctor);\n    if (!api) {\n      api = getAPIImpl$3(Ctor);\n      cache$3.set(Ctor, api);\n    }\n    return api;\n  }\n\n  /**\n   * Generates a typed API for Mat4\n   * */\n  function getAPIImpl$2(Ctor) {\n    var vec3 = getAPI$4(Ctor);\n    /**\n     * 4x4 Matrix math math functions.\n     *\n     * Almost all functions take an optional `newDst` argument. If it is not passed in the\n     * functions will create a new matrix. In other words you can do this\n     *\n     *     const mat = mat4.translation([1, 2, 3]);  // Creates a new translation matrix\n     *\n     * or\n     *\n     *     const mat = mat4.create();\n     *     mat4.translation([1, 2, 3], mat);  // Puts translation matrix in mat.\n     *\n     * The first style is often easier but depending on where it's used it generates garbage where\n     * as there is almost never allocation with the second style.\n     *\n     * It is always save to pass any matrix as the destination. So for example\n     *\n     *     const mat = mat4.identity();\n     *     const trans = mat4.translation([1, 2, 3]);\n     *     mat4.multiply(mat, trans, mat);  // Multiplies mat * trans and puts result in mat.\n     *\n     */\n    /**\n     * Create a Mat4 from values\n     *\n     * Note: Since passing in a raw JavaScript array\n     * is valid in all circumstances, if you want to\n     * force a JavaScript array into a Mat4's specified type\n     * it would be faster to use\n     *\n     * ```\n     * const m = mat4.clone(someJSArray);\n     * ```\n     *\n     * @param v0 - value for element 0\n     * @param v1 - value for element 1\n     * @param v2 - value for element 2\n     * @param v3 - value for element 3\n     * @param v4 - value for element 4\n     * @param v5 - value for element 5\n     * @param v6 - value for element 6\n     * @param v7 - value for element 7\n     * @param v8 - value for element 8\n     * @param v9 - value for element 9\n     * @param v10 - value for element 10\n     * @param v11 - value for element 11\n     * @param v12 - value for element 12\n     * @param v13 - value for element 13\n     * @param v14 - value for element 14\n     * @param v15 - value for element 15\n     * @returns created from values.\n     */\n    function create(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15) {\n      var newDst = new Ctor(16);\n      if (v0 !== undefined) {\n        newDst[0] = v0;\n        if (v1 !== undefined) {\n          newDst[1] = v1;\n          if (v2 !== undefined) {\n            newDst[2] = v2;\n            if (v3 !== undefined) {\n              newDst[3] = v3;\n              if (v4 !== undefined) {\n                newDst[4] = v4;\n                if (v5 !== undefined) {\n                  newDst[5] = v5;\n                  if (v6 !== undefined) {\n                    newDst[6] = v6;\n                    if (v7 !== undefined) {\n                      newDst[7] = v7;\n                      if (v8 !== undefined) {\n                        newDst[8] = v8;\n                        if (v9 !== undefined) {\n                          newDst[9] = v9;\n                          if (v10 !== undefined) {\n                            newDst[10] = v10;\n                            if (v11 !== undefined) {\n                              newDst[11] = v11;\n                              if (v12 !== undefined) {\n                                newDst[12] = v12;\n                                if (v13 !== undefined) {\n                                  newDst[13] = v13;\n                                  if (v14 !== undefined) {\n                                    newDst[14] = v14;\n                                    if (v15 !== undefined) {\n                                      newDst[15] = v15;\n                                    }\n                                  }\n                                }\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      return newDst;\n    }\n    /**\n     * Sets the values of a Mat4\n     * Also see {@link mat4.create} and {@link mat4.copy}\n     *\n     * @param v0 - value for element 0\n     * @param v1 - value for element 1\n     * @param v2 - value for element 2\n     * @param v3 - value for element 3\n     * @param v4 - value for element 4\n     * @param v5 - value for element 5\n     * @param v6 - value for element 6\n     * @param v7 - value for element 7\n     * @param v8 - value for element 8\n     * @param v9 - value for element 9\n     * @param v10 - value for element 10\n     * @param v11 - value for element 11\n     * @param v12 - value for element 12\n     * @param v13 - value for element 13\n     * @param v14 - value for element 14\n     * @param v15 - value for element 15\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns Mat4 created from values.\n     */\n    function set(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, dst) {\n      var newDst = dst != null ? dst : new Ctor(16);\n      newDst[0] = v0;\n      newDst[1] = v1;\n      newDst[2] = v2;\n      newDst[3] = v3;\n      newDst[4] = v4;\n      newDst[5] = v5;\n      newDst[6] = v6;\n      newDst[7] = v7;\n      newDst[8] = v8;\n      newDst[9] = v9;\n      newDst[10] = v10;\n      newDst[11] = v11;\n      newDst[12] = v12;\n      newDst[13] = v13;\n      newDst[14] = v14;\n      newDst[15] = v15;\n      return newDst;\n    }\n    /**\n     * Creates a Mat4 from a Mat3\n     * @param m3 - source matrix\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns Mat4 made from m3\n     */\n    function fromMat3(m3, dst) {\n      var newDst = dst != null ? dst : new Ctor(16);\n      newDst[0] = m3[0];\n      newDst[1] = m3[1];\n      newDst[2] = m3[2];\n      newDst[3] = 0;\n      newDst[4] = m3[4];\n      newDst[5] = m3[5];\n      newDst[6] = m3[6];\n      newDst[7] = 0;\n      newDst[8] = m3[8];\n      newDst[9] = m3[9];\n      newDst[10] = m3[10];\n      newDst[11] = 0;\n      newDst[12] = 0;\n      newDst[13] = 0;\n      newDst[14] = 0;\n      newDst[15] = 1;\n      return newDst;\n    }\n    /**\n     * Creates a Mat4 rotation matrix from a quaternion\n     * @param q - quaternion to create matrix from\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns Mat4 made from q\n     */\n    function fromQuat(q, dst) {\n      var newDst = dst != null ? dst : new Ctor(16);\n      var x = q[0];\n      var y = q[1];\n      var z = q[2];\n      var w = q[3];\n      var x2 = x + x;\n      var y2 = y + y;\n      var z2 = z + z;\n      var xx = x * x2;\n      var yx = y * x2;\n      var yy = y * y2;\n      var zx = z * x2;\n      var zy = z * y2;\n      var zz = z * z2;\n      var wx = w * x2;\n      var wy = w * y2;\n      var wz = w * z2;\n      newDst[0] = 1 - yy - zz;\n      newDst[1] = yx + wz;\n      newDst[2] = zx - wy;\n      newDst[3] = 0;\n      newDst[4] = yx - wz;\n      newDst[5] = 1 - xx - zz;\n      newDst[6] = zy + wx;\n      newDst[7] = 0;\n      newDst[8] = zx + wy;\n      newDst[9] = zy - wx;\n      newDst[10] = 1 - xx - yy;\n      newDst[11] = 0;\n      newDst[12] = 0;\n      newDst[13] = 0;\n      newDst[14] = 0;\n      newDst[15] = 1;\n      return newDst;\n    }\n    /**\n     * Negates a matrix.\n     * @param m - The matrix.\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns -m.\n     */\n    function negate(m, dst) {\n      var newDst = dst != null ? dst : new Ctor(16);\n      newDst[0] = -m[0];\n      newDst[1] = -m[1];\n      newDst[2] = -m[2];\n      newDst[3] = -m[3];\n      newDst[4] = -m[4];\n      newDst[5] = -m[5];\n      newDst[6] = -m[6];\n      newDst[7] = -m[7];\n      newDst[8] = -m[8];\n      newDst[9] = -m[9];\n      newDst[10] = -m[10];\n      newDst[11] = -m[11];\n      newDst[12] = -m[12];\n      newDst[13] = -m[13];\n      newDst[14] = -m[14];\n      newDst[15] = -m[15];\n      return newDst;\n    }\n    /**\n     * Copies a matrix. (same as {@link mat4.clone})\n     * Also see {@link mat4.create} and {@link mat4.set}\n     * @param m - The matrix.\n     * @param dst - The matrix. If not passed a new one is created.\n     * @returns A copy of m.\n     */\n    function copy(m, dst) {\n      var newDst = dst != null ? dst : new Ctor(16);\n      newDst[0] = m[0];\n      newDst[1] = m[1];\n      newDst[2] = m[2];\n      newDst[3] = m[3];\n      newDst[4] = m[4];\n      newDst[5] = m[5];\n      newDst[6] = m[6];\n      newDst[7] = m[7];\n      newDst[8] = m[8];\n      newDst[9] = m[9];\n      newDst[10] = m[10];\n      newDst[11] = m[11];\n      newDst[12] = m[12];\n      newDst[13] = m[13];\n      newDst[14] = m[14];\n      newDst[15] = m[15];\n      return newDst;\n    }\n    /**\n     * Copies a matrix (same as {@link mat4.copy})\n     * Also see {@link mat4.create} and {@link mat4.set}\n     * @param m - The matrix.\n     * @param dst - The matrix. If not passed a new one is created.\n     * @returns A copy of m.\n     */\n    var clone = copy;\n    /**\n     * Check if 2 matrices are approximately equal\n     * @param a - Operand matrix.\n     * @param b - Operand matrix.\n     * @returns true if matrices are approximately equal\n     */\n    function equalsApproximately(a, b) {\n      return Math.abs(a[0] - b[0]) < EPSILON && Math.abs(a[1] - b[1]) < EPSILON && Math.abs(a[2] - b[2]) < EPSILON && Math.abs(a[3] - b[3]) < EPSILON && Math.abs(a[4] - b[4]) < EPSILON && Math.abs(a[5] - b[5]) < EPSILON && Math.abs(a[6] - b[6]) < EPSILON && Math.abs(a[7] - b[7]) < EPSILON && Math.abs(a[8] - b[8]) < EPSILON && Math.abs(a[9] - b[9]) < EPSILON && Math.abs(a[10] - b[10]) < EPSILON && Math.abs(a[11] - b[11]) < EPSILON && Math.abs(a[12] - b[12]) < EPSILON && Math.abs(a[13] - b[13]) < EPSILON && Math.abs(a[14] - b[14]) < EPSILON && Math.abs(a[15] - b[15]) < EPSILON;\n    }\n    /**\n     * Check if 2 matrices are exactly equal\n     * @param a - Operand matrix.\n     * @param b - Operand matrix.\n     * @returns true if matrices are exactly equal\n     */\n    function equals(a, b) {\n      return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];\n    }\n    /**\n     * Creates a 4-by-4 identity matrix.\n     *\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns A 4-by-4 identity matrix.\n     */\n    function identity(dst) {\n      var newDst = dst != null ? dst : new Ctor(16);\n      newDst[0] = 1;\n      newDst[1] = 0;\n      newDst[2] = 0;\n      newDst[3] = 0;\n      newDst[4] = 0;\n      newDst[5] = 1;\n      newDst[6] = 0;\n      newDst[7] = 0;\n      newDst[8] = 0;\n      newDst[9] = 0;\n      newDst[10] = 1;\n      newDst[11] = 0;\n      newDst[12] = 0;\n      newDst[13] = 0;\n      newDst[14] = 0;\n      newDst[15] = 1;\n      return newDst;\n    }\n    /**\n     * Takes the transpose of a matrix.\n     * @param m - The matrix.\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The transpose of m.\n     */\n    function transpose(m, dst) {\n      var newDst = dst != null ? dst : new Ctor(16);\n      if (newDst === m) {\n        var t;\n        t = m[1];\n        m[1] = m[4];\n        m[4] = t;\n        t = m[2];\n        m[2] = m[8];\n        m[8] = t;\n        t = m[3];\n        m[3] = m[12];\n        m[12] = t;\n        t = m[6];\n        m[6] = m[9];\n        m[9] = t;\n        t = m[7];\n        m[7] = m[13];\n        m[13] = t;\n        t = m[11];\n        m[11] = m[14];\n        m[14] = t;\n        return newDst;\n      }\n      var m00 = m[0 * 4 + 0];\n      var m01 = m[0 * 4 + 1];\n      var m02 = m[0 * 4 + 2];\n      var m03 = m[0 * 4 + 3];\n      var m10 = m[1 * 4 + 0];\n      var m11 = m[1 * 4 + 1];\n      var m12 = m[1 * 4 + 2];\n      var m13 = m[1 * 4 + 3];\n      var m20 = m[2 * 4 + 0];\n      var m21 = m[2 * 4 + 1];\n      var m22 = m[2 * 4 + 2];\n      var m23 = m[2 * 4 + 3];\n      var m30 = m[3 * 4 + 0];\n      var m31 = m[3 * 4 + 1];\n      var m32 = m[3 * 4 + 2];\n      var m33 = m[3 * 4 + 3];\n      newDst[0] = m00;\n      newDst[1] = m10;\n      newDst[2] = m20;\n      newDst[3] = m30;\n      newDst[4] = m01;\n      newDst[5] = m11;\n      newDst[6] = m21;\n      newDst[7] = m31;\n      newDst[8] = m02;\n      newDst[9] = m12;\n      newDst[10] = m22;\n      newDst[11] = m32;\n      newDst[12] = m03;\n      newDst[13] = m13;\n      newDst[14] = m23;\n      newDst[15] = m33;\n      return newDst;\n    }\n    /**\n     * Computes the inverse of a 4-by-4 matrix.\n     * @param m - The matrix.\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The inverse of m.\n     */\n    function inverse(m, dst) {\n      var newDst = dst != null ? dst : new Ctor(16);\n      var m00 = m[0 * 4 + 0];\n      var m01 = m[0 * 4 + 1];\n      var m02 = m[0 * 4 + 2];\n      var m03 = m[0 * 4 + 3];\n      var m10 = m[1 * 4 + 0];\n      var m11 = m[1 * 4 + 1];\n      var m12 = m[1 * 4 + 2];\n      var m13 = m[1 * 4 + 3];\n      var m20 = m[2 * 4 + 0];\n      var m21 = m[2 * 4 + 1];\n      var m22 = m[2 * 4 + 2];\n      var m23 = m[2 * 4 + 3];\n      var m30 = m[3 * 4 + 0];\n      var m31 = m[3 * 4 + 1];\n      var m32 = m[3 * 4 + 2];\n      var m33 = m[3 * 4 + 3];\n      var tmp0 = m22 * m33;\n      var tmp1 = m32 * m23;\n      var tmp2 = m12 * m33;\n      var tmp3 = m32 * m13;\n      var tmp4 = m12 * m23;\n      var tmp5 = m22 * m13;\n      var tmp6 = m02 * m33;\n      var tmp7 = m32 * m03;\n      var tmp8 = m02 * m23;\n      var tmp9 = m22 * m03;\n      var tmp10 = m02 * m13;\n      var tmp11 = m12 * m03;\n      var tmp12 = m20 * m31;\n      var tmp13 = m30 * m21;\n      var tmp14 = m10 * m31;\n      var tmp15 = m30 * m11;\n      var tmp16 = m10 * m21;\n      var tmp17 = m20 * m11;\n      var tmp18 = m00 * m31;\n      var tmp19 = m30 * m01;\n      var tmp20 = m00 * m21;\n      var tmp21 = m20 * m01;\n      var tmp22 = m00 * m11;\n      var tmp23 = m10 * m01;\n      var t0 = tmp0 * m11 + tmp3 * m21 + tmp4 * m31 - (tmp1 * m11 + tmp2 * m21 + tmp5 * m31);\n      var t1 = tmp1 * m01 + tmp6 * m21 + tmp9 * m31 - (tmp0 * m01 + tmp7 * m21 + tmp8 * m31);\n      var t2 = tmp2 * m01 + tmp7 * m11 + tmp10 * m31 - (tmp3 * m01 + tmp6 * m11 + tmp11 * m31);\n      var t3 = tmp5 * m01 + tmp8 * m11 + tmp11 * m21 - (tmp4 * m01 + tmp9 * m11 + tmp10 * m21);\n      var d = 1 / (m00 * t0 + m10 * t1 + m20 * t2 + m30 * t3);\n      newDst[0] = d * t0;\n      newDst[1] = d * t1;\n      newDst[2] = d * t2;\n      newDst[3] = d * t3;\n      newDst[4] = d * (tmp1 * m10 + tmp2 * m20 + tmp5 * m30 - (tmp0 * m10 + tmp3 * m20 + tmp4 * m30));\n      newDst[5] = d * (tmp0 * m00 + tmp7 * m20 + tmp8 * m30 - (tmp1 * m00 + tmp6 * m20 + tmp9 * m30));\n      newDst[6] = d * (tmp3 * m00 + tmp6 * m10 + tmp11 * m30 - (tmp2 * m00 + tmp7 * m10 + tmp10 * m30));\n      newDst[7] = d * (tmp4 * m00 + tmp9 * m10 + tmp10 * m20 - (tmp5 * m00 + tmp8 * m10 + tmp11 * m20));\n      newDst[8] = d * (tmp12 * m13 + tmp15 * m23 + tmp16 * m33 - (tmp13 * m13 + tmp14 * m23 + tmp17 * m33));\n      newDst[9] = d * (tmp13 * m03 + tmp18 * m23 + tmp21 * m33 - (tmp12 * m03 + tmp19 * m23 + tmp20 * m33));\n      newDst[10] = d * (tmp14 * m03 + tmp19 * m13 + tmp22 * m33 - (tmp15 * m03 + tmp18 * m13 + tmp23 * m33));\n      newDst[11] = d * (tmp17 * m03 + tmp20 * m13 + tmp23 * m23 - (tmp16 * m03 + tmp21 * m13 + tmp22 * m23));\n      newDst[12] = d * (tmp14 * m22 + tmp17 * m32 + tmp13 * m12 - (tmp16 * m32 + tmp12 * m12 + tmp15 * m22));\n      newDst[13] = d * (tmp20 * m32 + tmp12 * m02 + tmp19 * m22 - (tmp18 * m22 + tmp21 * m32 + tmp13 * m02));\n      newDst[14] = d * (tmp18 * m12 + tmp23 * m32 + tmp15 * m02 - (tmp22 * m32 + tmp14 * m02 + tmp19 * m12));\n      newDst[15] = d * (tmp22 * m22 + tmp16 * m02 + tmp21 * m12 - (tmp20 * m12 + tmp23 * m22 + tmp17 * m02));\n      return newDst;\n    }\n    /**\n     * Compute the determinant of a matrix\n     * @param m - the matrix\n     * @returns the determinant\n     */\n    function determinant(m) {\n      var m00 = m[0 * 4 + 0];\n      var m01 = m[0 * 4 + 1];\n      var m02 = m[0 * 4 + 2];\n      var m03 = m[0 * 4 + 3];\n      var m10 = m[1 * 4 + 0];\n      var m11 = m[1 * 4 + 1];\n      var m12 = m[1 * 4 + 2];\n      var m13 = m[1 * 4 + 3];\n      var m20 = m[2 * 4 + 0];\n      var m21 = m[2 * 4 + 1];\n      var m22 = m[2 * 4 + 2];\n      var m23 = m[2 * 4 + 3];\n      var m30 = m[3 * 4 + 0];\n      var m31 = m[3 * 4 + 1];\n      var m32 = m[3 * 4 + 2];\n      var m33 = m[3 * 4 + 3];\n      var tmp0 = m22 * m33;\n      var tmp1 = m32 * m23;\n      var tmp2 = m12 * m33;\n      var tmp3 = m32 * m13;\n      var tmp4 = m12 * m23;\n      var tmp5 = m22 * m13;\n      var tmp6 = m02 * m33;\n      var tmp7 = m32 * m03;\n      var tmp8 = m02 * m23;\n      var tmp9 = m22 * m03;\n      var tmp10 = m02 * m13;\n      var tmp11 = m12 * m03;\n      var t0 = tmp0 * m11 + tmp3 * m21 + tmp4 * m31 - (tmp1 * m11 + tmp2 * m21 + tmp5 * m31);\n      var t1 = tmp1 * m01 + tmp6 * m21 + tmp9 * m31 - (tmp0 * m01 + tmp7 * m21 + tmp8 * m31);\n      var t2 = tmp2 * m01 + tmp7 * m11 + tmp10 * m31 - (tmp3 * m01 + tmp6 * m11 + tmp11 * m31);\n      var t3 = tmp5 * m01 + tmp8 * m11 + tmp11 * m21 - (tmp4 * m01 + tmp9 * m11 + tmp10 * m21);\n      return m00 * t0 + m10 * t1 + m20 * t2 + m30 * t3;\n    }\n    /**\n     * Computes the inverse of a 4-by-4 matrix. (same as inverse)\n     * @param m - The matrix.\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The inverse of m.\n     */\n    var invert = inverse;\n    /**\n     * Multiplies two 4-by-4 matrices with a on the left and b on the right\n     * @param a - The matrix on the left.\n     * @param b - The matrix on the right.\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The matrix product of a and b.\n     */\n    function multiply(a, b, dst) {\n      var newDst = dst != null ? dst : new Ctor(16);\n      var a00 = a[0];\n      var a01 = a[1];\n      var a02 = a[2];\n      var a03 = a[3];\n      var a10 = a[4 + 0];\n      var a11 = a[4 + 1];\n      var a12 = a[4 + 2];\n      var a13 = a[4 + 3];\n      var a20 = a[8 + 0];\n      var a21 = a[8 + 1];\n      var a22 = a[8 + 2];\n      var a23 = a[8 + 3];\n      var a30 = a[12 + 0];\n      var a31 = a[12 + 1];\n      var a32 = a[12 + 2];\n      var a33 = a[12 + 3];\n      var b00 = b[0];\n      var b01 = b[1];\n      var b02 = b[2];\n      var b03 = b[3];\n      var b10 = b[4 + 0];\n      var b11 = b[4 + 1];\n      var b12 = b[4 + 2];\n      var b13 = b[4 + 3];\n      var b20 = b[8 + 0];\n      var b21 = b[8 + 1];\n      var b22 = b[8 + 2];\n      var b23 = b[8 + 3];\n      var b30 = b[12 + 0];\n      var b31 = b[12 + 1];\n      var b32 = b[12 + 2];\n      var b33 = b[12 + 3];\n      newDst[0] = a00 * b00 + a10 * b01 + a20 * b02 + a30 * b03;\n      newDst[1] = a01 * b00 + a11 * b01 + a21 * b02 + a31 * b03;\n      newDst[2] = a02 * b00 + a12 * b01 + a22 * b02 + a32 * b03;\n      newDst[3] = a03 * b00 + a13 * b01 + a23 * b02 + a33 * b03;\n      newDst[4] = a00 * b10 + a10 * b11 + a20 * b12 + a30 * b13;\n      newDst[5] = a01 * b10 + a11 * b11 + a21 * b12 + a31 * b13;\n      newDst[6] = a02 * b10 + a12 * b11 + a22 * b12 + a32 * b13;\n      newDst[7] = a03 * b10 + a13 * b11 + a23 * b12 + a33 * b13;\n      newDst[8] = a00 * b20 + a10 * b21 + a20 * b22 + a30 * b23;\n      newDst[9] = a01 * b20 + a11 * b21 + a21 * b22 + a31 * b23;\n      newDst[10] = a02 * b20 + a12 * b21 + a22 * b22 + a32 * b23;\n      newDst[11] = a03 * b20 + a13 * b21 + a23 * b22 + a33 * b23;\n      newDst[12] = a00 * b30 + a10 * b31 + a20 * b32 + a30 * b33;\n      newDst[13] = a01 * b30 + a11 * b31 + a21 * b32 + a31 * b33;\n      newDst[14] = a02 * b30 + a12 * b31 + a22 * b32 + a32 * b33;\n      newDst[15] = a03 * b30 + a13 * b31 + a23 * b32 + a33 * b33;\n      return newDst;\n    }\n    /**\n     * Multiplies two 4-by-4 matrices with a on the left and b on the right (same as multiply)\n     * @param a - The matrix on the left.\n     * @param b - The matrix on the right.\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The matrix product of a and b.\n     */\n    var mul = multiply;\n    /**\n     * Sets the translation component of a 4-by-4 matrix to the given\n     * vector.\n     * @param a - The matrix.\n     * @param v - The vector.\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The matrix with translation set.\n     */\n    function setTranslation(a, v, dst) {\n      var newDst = dst != null ? dst : identity();\n      if (a !== newDst) {\n        newDst[0] = a[0];\n        newDst[1] = a[1];\n        newDst[2] = a[2];\n        newDst[3] = a[3];\n        newDst[4] = a[4];\n        newDst[5] = a[5];\n        newDst[6] = a[6];\n        newDst[7] = a[7];\n        newDst[8] = a[8];\n        newDst[9] = a[9];\n        newDst[10] = a[10];\n        newDst[11] = a[11];\n      }\n      newDst[12] = v[0];\n      newDst[13] = v[1];\n      newDst[14] = v[2];\n      newDst[15] = 1;\n      return newDst;\n    }\n    ///**\n    // * Returns the translation component of a 4-by-4 matrix as a vector with 3\n    // * entries.\n    // * @param m - The matrix.\n    // * @param dst - vector to hold result. If not passed a new one is created.\n    // * @returns The translation component of m.\n    // */\n    function getTranslation(m, dst) {\n      var newDst = dst != null ? dst : vec3.create();\n      newDst[0] = m[12];\n      newDst[1] = m[13];\n      newDst[2] = m[14];\n      return newDst;\n    }\n    /**\n     * Returns an axis of a 4x4 matrix as a vector with 3 entries\n     * @param m - The matrix.\n     * @param axis - The axis 0 = x, 1 = y, 2 = z;\n     * @returns The axis component of m.\n     */\n    function getAxis(m, axis, dst) {\n      var newDst = dst != null ? dst : vec3.create();\n      var off = axis * 4;\n      newDst[0] = m[off + 0];\n      newDst[1] = m[off + 1];\n      newDst[2] = m[off + 2];\n      return newDst;\n    }\n    /**\n     * Sets an axis of a 4x4 matrix as a vector with 3 entries\n     * @param m - The matrix.\n     * @param v - the axis vector\n     * @param axis - The axis  0 = x, 1 = y, 2 = z;\n     * @param dst - The matrix to set. If not passed a new one is created.\n     * @returns The matrix with axis set.\n     */\n    function setAxis(m, v, axis, dst) {\n      var newDst = dst === m ? dst : copy(m, dst);\n      var off = axis * 4;\n      newDst[off + 0] = v[0];\n      newDst[off + 1] = v[1];\n      newDst[off + 2] = v[2];\n      return newDst;\n    }\n    /**\n     * Returns the \"3d\" scaling component of the matrix\n     * @param m - The Matrix\n     * @param dst - The vector to set. If not passed a new one is created.\n     */\n    function getScaling(m, dst) {\n      var newDst = dst != null ? dst : vec3.create();\n      var xx = m[0];\n      var xy = m[1];\n      var xz = m[2];\n      var yx = m[4];\n      var yy = m[5];\n      var yz = m[6];\n      var zx = m[8];\n      var zy = m[9];\n      var zz = m[10];\n      newDst[0] = Math.sqrt(xx * xx + xy * xy + xz * xz);\n      newDst[1] = Math.sqrt(yx * yx + yy * yy + yz * yz);\n      newDst[2] = Math.sqrt(zx * zx + zy * zy + zz * zz);\n      return newDst;\n    }\n    /**\n     * Computes a 4-by-4 perspective transformation matrix given the angular height\n     * of the frustum, the aspect ratio, and the near and far clipping planes.  The\n     * arguments define a frustum extending in the negative z direction.  The given\n     * angle is the vertical angle of the frustum, and the horizontal angle is\n     * determined to produce the given aspect ratio.  The arguments near and far are\n     * the distances to the near and far clipping planes.  Note that near and far\n     * are not z coordinates, but rather they are distances along the negative\n     * z-axis.  The matrix generated sends the viewing frustum to the unit box.\n     * We assume a unit box extending from -1 to 1 in the x and y dimensions and\n     * from 0 to 1 in the z dimension.\n     *\n     * Note: If you pass `Infinity` for zFar then it will produce a projection matrix\n     * returns -Infinity for Z when transforming coordinates with Z <= 0 and +Infinity for Z\n     * otherwise.\n     *\n     * @param fieldOfViewYInRadians - The camera angle from top to bottom (in radians).\n     * @param aspect - The aspect ratio width / height.\n     * @param zNear - The depth (negative z coordinate)\n     *     of the near clipping plane.\n     * @param zFar - The depth (negative z coordinate)\n     *     of the far clipping plane.\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The perspective matrix.\n     */\n    function perspective(fieldOfViewYInRadians, aspect, zNear, zFar, dst) {\n      var newDst = dst != null ? dst : new Ctor(16);\n      var f = Math.tan(Math.PI * 0.5 - 0.5 * fieldOfViewYInRadians);\n      newDst[0] = f / aspect;\n      newDst[1] = 0;\n      newDst[2] = 0;\n      newDst[3] = 0;\n      newDst[4] = 0;\n      newDst[5] = f;\n      newDst[6] = 0;\n      newDst[7] = 0;\n      newDst[8] = 0;\n      newDst[9] = 0;\n      newDst[11] = -1;\n      newDst[12] = 0;\n      newDst[13] = 0;\n      newDst[15] = 0;\n      if (Number.isFinite(zFar)) {\n        var rangeInv = 1 / (zNear - zFar);\n        newDst[10] = zFar * rangeInv;\n        newDst[14] = zFar * zNear * rangeInv;\n      } else {\n        newDst[10] = -1;\n        newDst[14] = -zNear;\n      }\n      return newDst;\n    }\n    /**\n     * Computes a 4-by-4 reverse-z perspective transformation matrix given the angular height\n     * of the frustum, the aspect ratio, and the near and far clipping planes.  The\n     * arguments define a frustum extending in the negative z direction.  The given\n     * angle is the vertical angle of the frustum, and the horizontal angle is\n     * determined to produce the given aspect ratio.  The arguments near and far are\n     * the distances to the near and far clipping planes.  Note that near and far\n     * are not z coordinates, but rather they are distances along the negative\n     * z-axis.  The matrix generated sends the viewing frustum to the unit box.\n     * We assume a unit box extending from -1 to 1 in the x and y dimensions and\n     * from 1 (at -zNear) to 0 (at -zFar) in the z dimension.\n     *\n     * @param fieldOfViewYInRadians - The camera angle from top to bottom (in radians).\n     * @param aspect - The aspect ratio width / height.\n     * @param zNear - The depth (negative z coordinate)\n     *     of the near clipping plane.\n     * @param zFar - The depth (negative z coordinate)\n     *     of the far clipping plane. (default = Infinity)\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The perspective matrix.\n     */\n    function perspectiveReverseZ(fieldOfViewYInRadians, aspect, zNear) {\n      var zFar = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Infinity;\n      var dst = arguments.length > 4 ? arguments[4] : undefined;\n      var newDst = dst != null ? dst : new Ctor(16);\n      var f = 1 / Math.tan(fieldOfViewYInRadians * 0.5);\n      newDst[0] = f / aspect;\n      newDst[1] = 0;\n      newDst[2] = 0;\n      newDst[3] = 0;\n      newDst[4] = 0;\n      newDst[5] = f;\n      newDst[6] = 0;\n      newDst[7] = 0;\n      newDst[8] = 0;\n      newDst[9] = 0;\n      newDst[11] = -1;\n      newDst[12] = 0;\n      newDst[13] = 0;\n      newDst[15] = 0;\n      if (zFar === Infinity) {\n        newDst[10] = 0;\n        newDst[14] = zNear;\n      } else {\n        var rangeInv = 1 / (zFar - zNear);\n        newDst[10] = zNear * rangeInv;\n        newDst[14] = zFar * zNear * rangeInv;\n      }\n      return newDst;\n    }\n    /**\n     * Computes a 4-by-4 orthogonal transformation matrix that transforms from\n     * the given the left, right, bottom, and top dimensions to -1 +1 in x, and y\n     * and 0 to +1 in z.\n     * @param left - Left side of the near clipping plane viewport.\n     * @param right - Right side of the near clipping plane viewport.\n     * @param bottom - Bottom of the near clipping plane viewport.\n     * @param top - Top of the near clipping plane viewport.\n     * @param near - The depth (negative z coordinate)\n     *     of the near clipping plane.\n     * @param far - The depth (negative z coordinate)\n     *     of the far clipping plane.\n     * @param dst - Output matrix. If not passed a new one is created.\n     * @returns The orthographic projection matrix.\n     */\n    function ortho(left, right, bottom, top, near, far, dst) {\n      var newDst = dst != null ? dst : new Ctor(16);\n      newDst[0] = 2 / (right - left);\n      newDst[1] = 0;\n      newDst[2] = 0;\n      newDst[3] = 0;\n      newDst[4] = 0;\n      newDst[5] = 2 / (top - bottom);\n      newDst[6] = 0;\n      newDst[7] = 0;\n      newDst[8] = 0;\n      newDst[9] = 0;\n      newDst[10] = 1 / (near - far);\n      newDst[11] = 0;\n      newDst[12] = (right + left) / (left - right);\n      newDst[13] = (top + bottom) / (bottom - top);\n      newDst[14] = near / (near - far);\n      newDst[15] = 1;\n      return newDst;\n    }\n    /**\n     * Computes a 4-by-4 perspective transformation matrix given the left, right,\n     * top, bottom, near and far clipping planes. The arguments define a frustum\n     * extending in the negative z direction. The arguments near and far are the\n     * distances to the near and far clipping planes. Note that near and far are not\n     * z coordinates, but rather they are distances along the negative z-axis. The\n     * matrix generated sends the viewing frustum to the unit box. We assume a unit\n     * box extending from -1 to 1 in the x and y dimensions and from 0 to 1 in the z\n     * dimension.\n     * @param left - The x coordinate of the left plane of the box.\n     * @param right - The x coordinate of the right plane of the box.\n     * @param bottom - The y coordinate of the bottom plane of the box.\n     * @param top - The y coordinate of the right plane of the box.\n     * @param near - The negative z coordinate of the near plane of the box.\n     * @param far - The negative z coordinate of the far plane of the box.\n     * @param dst - Output matrix. If not passed a new one is created.\n     * @returns The perspective projection matrix.\n     */\n    function frustum(left, right, bottom, top, near, far, dst) {\n      var newDst = dst != null ? dst : new Ctor(16);\n      var dx = right - left;\n      var dy = top - bottom;\n      var dz = near - far;\n      newDst[0] = 2 * near / dx;\n      newDst[1] = 0;\n      newDst[2] = 0;\n      newDst[3] = 0;\n      newDst[4] = 0;\n      newDst[5] = 2 * near / dy;\n      newDst[6] = 0;\n      newDst[7] = 0;\n      newDst[8] = (left + right) / dx;\n      newDst[9] = (top + bottom) / dy;\n      newDst[10] = far / dz;\n      newDst[11] = -1;\n      newDst[12] = 0;\n      newDst[13] = 0;\n      newDst[14] = near * far / dz;\n      newDst[15] = 0;\n      return newDst;\n    }\n    /**\n     * Computes a 4-by-4 reverse-z perspective transformation matrix given the left, right,\n     * top, bottom, near and far clipping planes. The arguments define a frustum\n     * extending in the negative z direction. The arguments near and far are the\n     * distances to the near and far clipping planes. Note that near and far are not\n     * z coordinates, but rather they are distances along the negative z-axis. The\n     * matrix generated sends the viewing frustum to the unit box. We assume a unit\n     * box extending from -1 to 1 in the x and y dimensions and from 1 (-near) to 0 (-far) in the z\n     * dimension.\n     * @param left - The x coordinate of the left plane of the box.\n     * @param right - The x coordinate of the right plane of the box.\n     * @param bottom - The y coordinate of the bottom plane of the box.\n     * @param top - The y coordinate of the right plane of the box.\n     * @param near - The negative z coordinate of the near plane of the box.\n     * @param far - The negative z coordinate of the far plane of the box.\n     * @param dst - Output matrix. If not passed a new one is created.\n     * @returns The perspective projection matrix.\n     */\n    function frustumReverseZ(left, right, bottom, top, near) {\n      var far = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : Infinity;\n      var dst = arguments.length > 6 ? arguments[6] : undefined;\n      var newDst = dst != null ? dst : new Ctor(16);\n      var dx = right - left;\n      var dy = top - bottom;\n      newDst[0] = 2 * near / dx;\n      newDst[1] = 0;\n      newDst[2] = 0;\n      newDst[3] = 0;\n      newDst[4] = 0;\n      newDst[5] = 2 * near / dy;\n      newDst[6] = 0;\n      newDst[7] = 0;\n      newDst[8] = (left + right) / dx;\n      newDst[9] = (top + bottom) / dy;\n      newDst[11] = -1;\n      newDst[12] = 0;\n      newDst[13] = 0;\n      newDst[15] = 0;\n      if (far === Infinity) {\n        newDst[10] = 0;\n        newDst[14] = near;\n      } else {\n        var rangeInv = 1 / (far - near);\n        newDst[10] = near * rangeInv;\n        newDst[14] = far * near * rangeInv;\n      }\n      return newDst;\n    }\n    var xAxis = vec3.create();\n    var yAxis = vec3.create();\n    var zAxis = vec3.create();\n    /**\n     * Computes a 4-by-4 aim transformation.\n     *\n     * This is a matrix which positions an object aiming down positive Z.\n     * toward the target.\n     *\n     * Note: this is **NOT** the inverse of lookAt as lookAt looks at negative Z.\n     *\n     * @param position - The position of the object.\n     * @param target - The position meant to be aimed at.\n     * @param up - A vector pointing up.\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The aim matrix.\n     */\n    function aim(position, target, up, dst) {\n      var newDst = dst != null ? dst : new Ctor(16);\n      vec3.normalize(vec3.subtract(target, position, zAxis), zAxis);\n      vec3.normalize(vec3.cross(up, zAxis, xAxis), xAxis);\n      vec3.normalize(vec3.cross(zAxis, xAxis, yAxis), yAxis);\n      newDst[0] = xAxis[0];\n      newDst[1] = xAxis[1];\n      newDst[2] = xAxis[2];\n      newDst[3] = 0;\n      newDst[4] = yAxis[0];\n      newDst[5] = yAxis[1];\n      newDst[6] = yAxis[2];\n      newDst[7] = 0;\n      newDst[8] = zAxis[0];\n      newDst[9] = zAxis[1];\n      newDst[10] = zAxis[2];\n      newDst[11] = 0;\n      newDst[12] = position[0];\n      newDst[13] = position[1];\n      newDst[14] = position[2];\n      newDst[15] = 1;\n      return newDst;\n    }\n    /**\n     * Computes a 4-by-4 camera aim transformation.\n     *\n     * This is a matrix which positions an object aiming down negative Z.\n     * toward the target.\n     *\n     * Note: this is the inverse of `lookAt`\n     *\n     * @param eye - The position of the object.\n     * @param target - The position meant to be aimed at.\n     * @param up - A vector pointing up.\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The aim matrix.\n     */\n    function cameraAim(eye, target, up, dst) {\n      var newDst = dst != null ? dst : new Ctor(16);\n      vec3.normalize(vec3.subtract(eye, target, zAxis), zAxis);\n      vec3.normalize(vec3.cross(up, zAxis, xAxis), xAxis);\n      vec3.normalize(vec3.cross(zAxis, xAxis, yAxis), yAxis);\n      newDst[0] = xAxis[0];\n      newDst[1] = xAxis[1];\n      newDst[2] = xAxis[2];\n      newDst[3] = 0;\n      newDst[4] = yAxis[0];\n      newDst[5] = yAxis[1];\n      newDst[6] = yAxis[2];\n      newDst[7] = 0;\n      newDst[8] = zAxis[0];\n      newDst[9] = zAxis[1];\n      newDst[10] = zAxis[2];\n      newDst[11] = 0;\n      newDst[12] = eye[0];\n      newDst[13] = eye[1];\n      newDst[14] = eye[2];\n      newDst[15] = 1;\n      return newDst;\n    }\n    /**\n     * Computes a 4-by-4 view transformation.\n     *\n     * This is a view matrix which transforms all other objects\n     * to be in the space of the view defined by the parameters.\n     *\n     * @param eye - The position of the object.\n     * @param target - The position meant to be aimed at.\n     * @param up - A vector pointing up.\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The look-at matrix.\n     */\n    function lookAt(eye, target, up, dst) {\n      var newDst = dst != null ? dst : new Ctor(16);\n      vec3.normalize(vec3.subtract(eye, target, zAxis), zAxis);\n      vec3.normalize(vec3.cross(up, zAxis, xAxis), xAxis);\n      vec3.normalize(vec3.cross(zAxis, xAxis, yAxis), yAxis);\n      newDst[0] = xAxis[0];\n      newDst[1] = yAxis[0];\n      newDst[2] = zAxis[0];\n      newDst[3] = 0;\n      newDst[4] = xAxis[1];\n      newDst[5] = yAxis[1];\n      newDst[6] = zAxis[1];\n      newDst[7] = 0;\n      newDst[8] = xAxis[2];\n      newDst[9] = yAxis[2];\n      newDst[10] = zAxis[2];\n      newDst[11] = 0;\n      newDst[12] = -(xAxis[0] * eye[0] + xAxis[1] * eye[1] + xAxis[2] * eye[2]);\n      newDst[13] = -(yAxis[0] * eye[0] + yAxis[1] * eye[1] + yAxis[2] * eye[2]);\n      newDst[14] = -(zAxis[0] * eye[0] + zAxis[1] * eye[1] + zAxis[2] * eye[2]);\n      newDst[15] = 1;\n      return newDst;\n    }\n    /**\n     * Creates a 4-by-4 matrix which translates by the given vector v.\n     * @param v - The vector by\n     *     which to translate.\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The translation matrix.\n     */\n    function translation(v, dst) {\n      var newDst = dst != null ? dst : new Ctor(16);\n      newDst[0] = 1;\n      newDst[1] = 0;\n      newDst[2] = 0;\n      newDst[3] = 0;\n      newDst[4] = 0;\n      newDst[5] = 1;\n      newDst[6] = 0;\n      newDst[7] = 0;\n      newDst[8] = 0;\n      newDst[9] = 0;\n      newDst[10] = 1;\n      newDst[11] = 0;\n      newDst[12] = v[0];\n      newDst[13] = v[1];\n      newDst[14] = v[2];\n      newDst[15] = 1;\n      return newDst;\n    }\n    /**\n     * Translates the given 4-by-4 matrix by the given vector v.\n     * @param m - The matrix.\n     * @param v - The vector by\n     *     which to translate.\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The translated matrix.\n     */\n    function translate(m, v, dst) {\n      var newDst = dst != null ? dst : new Ctor(16);\n      var v0 = v[0];\n      var v1 = v[1];\n      var v2 = v[2];\n      var m00 = m[0];\n      var m01 = m[1];\n      var m02 = m[2];\n      var m03 = m[3];\n      var m10 = m[1 * 4 + 0];\n      var m11 = m[1 * 4 + 1];\n      var m12 = m[1 * 4 + 2];\n      var m13 = m[1 * 4 + 3];\n      var m20 = m[2 * 4 + 0];\n      var m21 = m[2 * 4 + 1];\n      var m22 = m[2 * 4 + 2];\n      var m23 = m[2 * 4 + 3];\n      var m30 = m[3 * 4 + 0];\n      var m31 = m[3 * 4 + 1];\n      var m32 = m[3 * 4 + 2];\n      var m33 = m[3 * 4 + 3];\n      if (m !== newDst) {\n        newDst[0] = m00;\n        newDst[1] = m01;\n        newDst[2] = m02;\n        newDst[3] = m03;\n        newDst[4] = m10;\n        newDst[5] = m11;\n        newDst[6] = m12;\n        newDst[7] = m13;\n        newDst[8] = m20;\n        newDst[9] = m21;\n        newDst[10] = m22;\n        newDst[11] = m23;\n      }\n      newDst[12] = m00 * v0 + m10 * v1 + m20 * v2 + m30;\n      newDst[13] = m01 * v0 + m11 * v1 + m21 * v2 + m31;\n      newDst[14] = m02 * v0 + m12 * v1 + m22 * v2 + m32;\n      newDst[15] = m03 * v0 + m13 * v1 + m23 * v2 + m33;\n      return newDst;\n    }\n    /**\n     * Creates a 4-by-4 matrix which rotates around the x-axis by the given angle.\n     * @param angleInRadians - The angle by which to rotate (in radians).\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The rotation matrix.\n     */\n    function rotationX(angleInRadians, dst) {\n      var newDst = dst != null ? dst : new Ctor(16);\n      var c = Math.cos(angleInRadians);\n      var s = Math.sin(angleInRadians);\n      newDst[0] = 1;\n      newDst[1] = 0;\n      newDst[2] = 0;\n      newDst[3] = 0;\n      newDst[4] = 0;\n      newDst[5] = c;\n      newDst[6] = s;\n      newDst[7] = 0;\n      newDst[8] = 0;\n      newDst[9] = -s;\n      newDst[10] = c;\n      newDst[11] = 0;\n      newDst[12] = 0;\n      newDst[13] = 0;\n      newDst[14] = 0;\n      newDst[15] = 1;\n      return newDst;\n    }\n    /**\n     * Rotates the given 4-by-4 matrix around the x-axis by the given\n     * angle.\n     * @param m - The matrix.\n     * @param angleInRadians - The angle by which to rotate (in radians).\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The rotated matrix.\n     */\n    function rotateX(m, angleInRadians, dst) {\n      var newDst = dst != null ? dst : new Ctor(16);\n      var m10 = m[4];\n      var m11 = m[5];\n      var m12 = m[6];\n      var m13 = m[7];\n      var m20 = m[8];\n      var m21 = m[9];\n      var m22 = m[10];\n      var m23 = m[11];\n      var c = Math.cos(angleInRadians);\n      var s = Math.sin(angleInRadians);\n      newDst[4] = c * m10 + s * m20;\n      newDst[5] = c * m11 + s * m21;\n      newDst[6] = c * m12 + s * m22;\n      newDst[7] = c * m13 + s * m23;\n      newDst[8] = c * m20 - s * m10;\n      newDst[9] = c * m21 - s * m11;\n      newDst[10] = c * m22 - s * m12;\n      newDst[11] = c * m23 - s * m13;\n      if (m !== newDst) {\n        newDst[0] = m[0];\n        newDst[1] = m[1];\n        newDst[2] = m[2];\n        newDst[3] = m[3];\n        newDst[12] = m[12];\n        newDst[13] = m[13];\n        newDst[14] = m[14];\n        newDst[15] = m[15];\n      }\n      return newDst;\n    }\n    /**\n     * Creates a 4-by-4 matrix which rotates around the y-axis by the given angle.\n     * @param angleInRadians - The angle by which to rotate (in radians).\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The rotation matrix.\n     */\n    function rotationY(angleInRadians, dst) {\n      var newDst = dst != null ? dst : new Ctor(16);\n      var c = Math.cos(angleInRadians);\n      var s = Math.sin(angleInRadians);\n      newDst[0] = c;\n      newDst[1] = 0;\n      newDst[2] = -s;\n      newDst[3] = 0;\n      newDst[4] = 0;\n      newDst[5] = 1;\n      newDst[6] = 0;\n      newDst[7] = 0;\n      newDst[8] = s;\n      newDst[9] = 0;\n      newDst[10] = c;\n      newDst[11] = 0;\n      newDst[12] = 0;\n      newDst[13] = 0;\n      newDst[14] = 0;\n      newDst[15] = 1;\n      return newDst;\n    }\n    /**\n     * Rotates the given 4-by-4 matrix around the y-axis by the given\n     * angle.\n     * @param m - The matrix.\n     * @param angleInRadians - The angle by which to rotate (in radians).\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The rotated matrix.\n     */\n    function rotateY(m, angleInRadians, dst) {\n      var newDst = dst != null ? dst : new Ctor(16);\n      var m00 = m[0 * 4 + 0];\n      var m01 = m[0 * 4 + 1];\n      var m02 = m[0 * 4 + 2];\n      var m03 = m[0 * 4 + 3];\n      var m20 = m[2 * 4 + 0];\n      var m21 = m[2 * 4 + 1];\n      var m22 = m[2 * 4 + 2];\n      var m23 = m[2 * 4 + 3];\n      var c = Math.cos(angleInRadians);\n      var s = Math.sin(angleInRadians);\n      newDst[0] = c * m00 - s * m20;\n      newDst[1] = c * m01 - s * m21;\n      newDst[2] = c * m02 - s * m22;\n      newDst[3] = c * m03 - s * m23;\n      newDst[8] = c * m20 + s * m00;\n      newDst[9] = c * m21 + s * m01;\n      newDst[10] = c * m22 + s * m02;\n      newDst[11] = c * m23 + s * m03;\n      if (m !== newDst) {\n        newDst[4] = m[4];\n        newDst[5] = m[5];\n        newDst[6] = m[6];\n        newDst[7] = m[7];\n        newDst[12] = m[12];\n        newDst[13] = m[13];\n        newDst[14] = m[14];\n        newDst[15] = m[15];\n      }\n      return newDst;\n    }\n    /**\n     * Creates a 4-by-4 matrix which rotates around the z-axis by the given angle.\n     * @param angleInRadians - The angle by which to rotate (in radians).\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The rotation matrix.\n     */\n    function rotationZ(angleInRadians, dst) {\n      var newDst = dst != null ? dst : new Ctor(16);\n      var c = Math.cos(angleInRadians);\n      var s = Math.sin(angleInRadians);\n      newDst[0] = c;\n      newDst[1] = s;\n      newDst[2] = 0;\n      newDst[3] = 0;\n      newDst[4] = -s;\n      newDst[5] = c;\n      newDst[6] = 0;\n      newDst[7] = 0;\n      newDst[8] = 0;\n      newDst[9] = 0;\n      newDst[10] = 1;\n      newDst[11] = 0;\n      newDst[12] = 0;\n      newDst[13] = 0;\n      newDst[14] = 0;\n      newDst[15] = 1;\n      return newDst;\n    }\n    /**\n     * Rotates the given 4-by-4 matrix around the z-axis by the given\n     * angle.\n     * @param m - The matrix.\n     * @param angleInRadians - The angle by which to rotate (in radians).\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The rotated matrix.\n     */\n    function rotateZ(m, angleInRadians, dst) {\n      var newDst = dst != null ? dst : new Ctor(16);\n      var m00 = m[0 * 4 + 0];\n      var m01 = m[0 * 4 + 1];\n      var m02 = m[0 * 4 + 2];\n      var m03 = m[0 * 4 + 3];\n      var m10 = m[1 * 4 + 0];\n      var m11 = m[1 * 4 + 1];\n      var m12 = m[1 * 4 + 2];\n      var m13 = m[1 * 4 + 3];\n      var c = Math.cos(angleInRadians);\n      var s = Math.sin(angleInRadians);\n      newDst[0] = c * m00 + s * m10;\n      newDst[1] = c * m01 + s * m11;\n      newDst[2] = c * m02 + s * m12;\n      newDst[3] = c * m03 + s * m13;\n      newDst[4] = c * m10 - s * m00;\n      newDst[5] = c * m11 - s * m01;\n      newDst[6] = c * m12 - s * m02;\n      newDst[7] = c * m13 - s * m03;\n      if (m !== newDst) {\n        newDst[8] = m[8];\n        newDst[9] = m[9];\n        newDst[10] = m[10];\n        newDst[11] = m[11];\n        newDst[12] = m[12];\n        newDst[13] = m[13];\n        newDst[14] = m[14];\n        newDst[15] = m[15];\n      }\n      return newDst;\n    }\n    /**\n     * Creates a 4-by-4 matrix which rotates around the given axis by the given\n     * angle.\n     * @param axis - The axis\n     *     about which to rotate.\n     * @param angleInRadians - The angle by which to rotate (in radians).\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns A matrix which rotates angle radians\n     *     around the axis.\n     */\n    function axisRotation(axis, angleInRadians, dst) {\n      var newDst = dst != null ? dst : new Ctor(16);\n      var x = axis[0];\n      var y = axis[1];\n      var z = axis[2];\n      var n = Math.sqrt(x * x + y * y + z * z);\n      x /= n;\n      y /= n;\n      z /= n;\n      var xx = x * x;\n      var yy = y * y;\n      var zz = z * z;\n      var c = Math.cos(angleInRadians);\n      var s = Math.sin(angleInRadians);\n      var oneMinusCosine = 1 - c;\n      newDst[0] = xx + (1 - xx) * c;\n      newDst[1] = x * y * oneMinusCosine + z * s;\n      newDst[2] = x * z * oneMinusCosine - y * s;\n      newDst[3] = 0;\n      newDst[4] = x * y * oneMinusCosine - z * s;\n      newDst[5] = yy + (1 - yy) * c;\n      newDst[6] = y * z * oneMinusCosine + x * s;\n      newDst[7] = 0;\n      newDst[8] = x * z * oneMinusCosine + y * s;\n      newDst[9] = y * z * oneMinusCosine - x * s;\n      newDst[10] = zz + (1 - zz) * c;\n      newDst[11] = 0;\n      newDst[12] = 0;\n      newDst[13] = 0;\n      newDst[14] = 0;\n      newDst[15] = 1;\n      return newDst;\n    }\n    /**\n     * Creates a 4-by-4 matrix which rotates around the given axis by the given\n     * angle. (same as axisRotation)\n     * @param axis - The axis\n     *     about which to rotate.\n     * @param angleInRadians - The angle by which to rotate (in radians).\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns A matrix which rotates angle radians\n     *     around the axis.\n     */\n    var rotation = axisRotation;\n    /**\n     * Rotates the given 4-by-4 matrix around the given axis by the\n     * given angle.\n     * @param m - The matrix.\n     * @param axis - The axis\n     *     about which to rotate.\n     * @param angleInRadians - The angle by which to rotate (in radians).\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The rotated matrix.\n     */\n    function axisRotate(m, axis, angleInRadians, dst) {\n      var newDst = dst != null ? dst : new Ctor(16);\n      var x = axis[0];\n      var y = axis[1];\n      var z = axis[2];\n      var n = Math.sqrt(x * x + y * y + z * z);\n      x /= n;\n      y /= n;\n      z /= n;\n      var xx = x * x;\n      var yy = y * y;\n      var zz = z * z;\n      var c = Math.cos(angleInRadians);\n      var s = Math.sin(angleInRadians);\n      var oneMinusCosine = 1 - c;\n      var r00 = xx + (1 - xx) * c;\n      var r01 = x * y * oneMinusCosine + z * s;\n      var r02 = x * z * oneMinusCosine - y * s;\n      var r10 = x * y * oneMinusCosine - z * s;\n      var r11 = yy + (1 - yy) * c;\n      var r12 = y * z * oneMinusCosine + x * s;\n      var r20 = x * z * oneMinusCosine + y * s;\n      var r21 = y * z * oneMinusCosine - x * s;\n      var r22 = zz + (1 - zz) * c;\n      var m00 = m[0];\n      var m01 = m[1];\n      var m02 = m[2];\n      var m03 = m[3];\n      var m10 = m[4];\n      var m11 = m[5];\n      var m12 = m[6];\n      var m13 = m[7];\n      var m20 = m[8];\n      var m21 = m[9];\n      var m22 = m[10];\n      var m23 = m[11];\n      newDst[0] = r00 * m00 + r01 * m10 + r02 * m20;\n      newDst[1] = r00 * m01 + r01 * m11 + r02 * m21;\n      newDst[2] = r00 * m02 + r01 * m12 + r02 * m22;\n      newDst[3] = r00 * m03 + r01 * m13 + r02 * m23;\n      newDst[4] = r10 * m00 + r11 * m10 + r12 * m20;\n      newDst[5] = r10 * m01 + r11 * m11 + r12 * m21;\n      newDst[6] = r10 * m02 + r11 * m12 + r12 * m22;\n      newDst[7] = r10 * m03 + r11 * m13 + r12 * m23;\n      newDst[8] = r20 * m00 + r21 * m10 + r22 * m20;\n      newDst[9] = r20 * m01 + r21 * m11 + r22 * m21;\n      newDst[10] = r20 * m02 + r21 * m12 + r22 * m22;\n      newDst[11] = r20 * m03 + r21 * m13 + r22 * m23;\n      if (m !== newDst) {\n        newDst[12] = m[12];\n        newDst[13] = m[13];\n        newDst[14] = m[14];\n        newDst[15] = m[15];\n      }\n      return newDst;\n    }\n    /**\n     * Rotates the given 4-by-4 matrix around the given axis by the\n     * given angle. (same as rotate)\n     * @param m - The matrix.\n     * @param axis - The axis\n     *     about which to rotate.\n     * @param angleInRadians - The angle by which to rotate (in radians).\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The rotated matrix.\n     */\n    var rotate = axisRotate;\n    /**\n     * Creates a 4-by-4 matrix which scales in each dimension by an amount given by\n     * the corresponding entry in the given vector; assumes the vector has three\n     * entries.\n     * @param v - A vector of\n     *     three entries specifying the factor by which to scale in each dimension.\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The scaling matrix.\n     */\n    function scaling(v, dst) {\n      var newDst = dst != null ? dst : new Ctor(16);\n      newDst[0] = v[0];\n      newDst[1] = 0;\n      newDst[2] = 0;\n      newDst[3] = 0;\n      newDst[4] = 0;\n      newDst[5] = v[1];\n      newDst[6] = 0;\n      newDst[7] = 0;\n      newDst[8] = 0;\n      newDst[9] = 0;\n      newDst[10] = v[2];\n      newDst[11] = 0;\n      newDst[12] = 0;\n      newDst[13] = 0;\n      newDst[14] = 0;\n      newDst[15] = 1;\n      return newDst;\n    }\n    /**\n     * Scales the given 4-by-4 matrix in each dimension by an amount\n     * given by the corresponding entry in the given vector; assumes the vector has\n     * three entries.\n     * @param m - The matrix to be modified.\n     * @param v - A vector of three entries specifying the\n     *     factor by which to scale in each dimension.\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The scaled matrix.\n     */\n    function scale(m, v, dst) {\n      var newDst = dst != null ? dst : new Ctor(16);\n      var v0 = v[0];\n      var v1 = v[1];\n      var v2 = v[2];\n      newDst[0] = v0 * m[0 * 4 + 0];\n      newDst[1] = v0 * m[0 * 4 + 1];\n      newDst[2] = v0 * m[0 * 4 + 2];\n      newDst[3] = v0 * m[0 * 4 + 3];\n      newDst[4] = v1 * m[1 * 4 + 0];\n      newDst[5] = v1 * m[1 * 4 + 1];\n      newDst[6] = v1 * m[1 * 4 + 2];\n      newDst[7] = v1 * m[1 * 4 + 3];\n      newDst[8] = v2 * m[2 * 4 + 0];\n      newDst[9] = v2 * m[2 * 4 + 1];\n      newDst[10] = v2 * m[2 * 4 + 2];\n      newDst[11] = v2 * m[2 * 4 + 3];\n      if (m !== newDst) {\n        newDst[12] = m[12];\n        newDst[13] = m[13];\n        newDst[14] = m[14];\n        newDst[15] = m[15];\n      }\n      return newDst;\n    }\n    /**\n     * Creates a 4-by-4 matrix which scales a uniform amount in each dimension.\n     * @param s - the amount to scale\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The scaling matrix.\n     */\n    function uniformScaling(s, dst) {\n      var newDst = dst != null ? dst : new Ctor(16);\n      newDst[0] = s;\n      newDst[1] = 0;\n      newDst[2] = 0;\n      newDst[3] = 0;\n      newDst[4] = 0;\n      newDst[5] = s;\n      newDst[6] = 0;\n      newDst[7] = 0;\n      newDst[8] = 0;\n      newDst[9] = 0;\n      newDst[10] = s;\n      newDst[11] = 0;\n      newDst[12] = 0;\n      newDst[13] = 0;\n      newDst[14] = 0;\n      newDst[15] = 1;\n      return newDst;\n    }\n    /**\n     * Scales the given 4-by-4 matrix in each dimension by a uniform scale.\n     * @param m - The matrix to be modified.\n     * @param s - The amount to scale.\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The scaled matrix.\n     */\n    function uniformScale(m, s, dst) {\n      var newDst = dst != null ? dst : new Ctor(16);\n      newDst[0] = s * m[0 * 4 + 0];\n      newDst[1] = s * m[0 * 4 + 1];\n      newDst[2] = s * m[0 * 4 + 2];\n      newDst[3] = s * m[0 * 4 + 3];\n      newDst[4] = s * m[1 * 4 + 0];\n      newDst[5] = s * m[1 * 4 + 1];\n      newDst[6] = s * m[1 * 4 + 2];\n      newDst[7] = s * m[1 * 4 + 3];\n      newDst[8] = s * m[2 * 4 + 0];\n      newDst[9] = s * m[2 * 4 + 1];\n      newDst[10] = s * m[2 * 4 + 2];\n      newDst[11] = s * m[2 * 4 + 3];\n      if (m !== newDst) {\n        newDst[12] = m[12];\n        newDst[13] = m[13];\n        newDst[14] = m[14];\n        newDst[15] = m[15];\n      }\n      return newDst;\n    }\n    return {\n      create: create,\n      set: set,\n      fromMat3: fromMat3,\n      fromQuat: fromQuat,\n      negate: negate,\n      copy: copy,\n      clone: clone,\n      equalsApproximately: equalsApproximately,\n      equals: equals,\n      identity: identity,\n      transpose: transpose,\n      inverse: inverse,\n      determinant: determinant,\n      invert: invert,\n      multiply: multiply,\n      mul: mul,\n      setTranslation: setTranslation,\n      getTranslation: getTranslation,\n      getAxis: getAxis,\n      setAxis: setAxis,\n      getScaling: getScaling,\n      perspective: perspective,\n      perspectiveReverseZ: perspectiveReverseZ,\n      ortho: ortho,\n      frustum: frustum,\n      frustumReverseZ: frustumReverseZ,\n      aim: aim,\n      cameraAim: cameraAim,\n      lookAt: lookAt,\n      translation: translation,\n      translate: translate,\n      rotationX: rotationX,\n      rotateX: rotateX,\n      rotationY: rotationY,\n      rotateY: rotateY,\n      rotationZ: rotationZ,\n      rotateZ: rotateZ,\n      axisRotation: axisRotation,\n      rotation: rotation,\n      axisRotate: axisRotate,\n      rotate: rotate,\n      scaling: scaling,\n      scale: scale,\n      uniformScaling: uniformScaling,\n      uniformScale: uniformScale\n    };\n  }\n  var cache$2 = new Map();\n  function getAPI$2(Ctor) {\n    var api = cache$2.get(Ctor);\n    if (!api) {\n      api = getAPIImpl$2(Ctor);\n      cache$2.set(Ctor, api);\n    }\n    return api;\n  }\n\n  /*\n   * Copyright 2022 Gregg Tavares\n   *\n   * Permission is hereby granted, free of charge, to any person obtaining a\n   * copy of this software and associated documentation files (the \"Software\"),\n   * to deal in the Software without restriction, including without limitation\n   * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n   * and/or sell copies of the Software, and to permit persons to whom the\n   * Software is furnished to do so, subject to the following conditions:\n   *\n   * The above copyright notice and this permission notice shall be included in\n   * all copies or substantial portions of the Software.\n   *\n   * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n   * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n   * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n   * DEALINGS IN THE SOFTWARE.\n   */\n  /**\n   * Generates am typed API for Qud\n   * */\n  function getAPIImpl$1(Ctor) {\n    var vec3 = getAPI$4(Ctor);\n    /**\n     * Creates a quat4; may be called with x, y, z to set initial values.\n     * @param x - Initial x value.\n     * @param y - Initial y value.\n     * @param z - Initial z value.\n     * @param w - Initial w value.\n     * @returns the created vector\n     */\n    function create(x, y, z, w) {\n      var newDst = new Ctor(4);\n      if (x !== undefined) {\n        newDst[0] = x;\n        if (y !== undefined) {\n          newDst[1] = y;\n          if (z !== undefined) {\n            newDst[2] = z;\n            if (w !== undefined) {\n              newDst[3] = w;\n            }\n          }\n        }\n      }\n      return newDst;\n    }\n    /**\n     * Creates a Quat; may be called with x, y, z to set initial values. (same as create)\n     * @param x - Initial x value.\n     * @param y - Initial y value.\n     * @param z - Initial z value.\n     * @param z - Initial w value.\n     * @returns the created vector\n     */\n    var fromValues = create;\n    /**\n     * Sets the values of a Quat\n     * Also see {@link quat.create} and {@link quat.copy}\n     *\n     * @param x first value\n     * @param y second value\n     * @param z third value\n     * @param w fourth value\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A vector with its elements set.\n     */\n    function set(x, y, z, w, dst) {\n      var newDst = dst != null ? dst : new Ctor(4);\n      newDst[0] = x;\n      newDst[1] = y;\n      newDst[2] = z;\n      newDst[3] = w;\n      return newDst;\n    }\n    /**\n     * Sets a quaternion from the given angle and  axis,\n     * then returns it.\n     *\n     * @param axis - the axis to rotate around\n     * @param angleInRadians - the angle\n     * @param dst - quaternion to hold result. If not passed in a new one is created.\n     * @returns The quaternion that represents the given axis and angle\n     **/\n    function fromAxisAngle(axis, angleInRadians, dst) {\n      var newDst = dst != null ? dst : new Ctor(4);\n      var halfAngle = angleInRadians * 0.5;\n      var s = Math.sin(halfAngle);\n      newDst[0] = s * axis[0];\n      newDst[1] = s * axis[1];\n      newDst[2] = s * axis[2];\n      newDst[3] = Math.cos(halfAngle);\n      return newDst;\n    }\n    /**\n     * Gets the rotation axis and angle\n     * @param q - quaternion to compute from\n     * @param dst - Vec3 to hold result. If not passed in a new one is created.\n     * @return angle and axis\n     */\n    function toAxisAngle(q, dst) {\n      var newDst = dst != null ? dst : vec3.create(3);\n      var angle = Math.acos(q[3]) * 2;\n      var s = Math.sin(angle * 0.5);\n      if (s > EPSILON) {\n        newDst[0] = q[0] / s;\n        newDst[1] = q[1] / s;\n        newDst[2] = q[2] / s;\n      } else {\n        newDst[0] = 1;\n        newDst[1] = 0;\n        newDst[2] = 0;\n      }\n      return {\n        angle: angle,\n        axis: newDst\n      };\n    }\n    /**\n     * Returns the angle in degrees between two rotations a and b.\n     * @param a - quaternion a\n     * @param b - quaternion b\n     * @return angle in radians between the two quaternions\n     */\n    function angle(a, b) {\n      var d = dot(a, b);\n      return Math.acos(2 * d * d - 1);\n    }\n    /**\n     * Multiplies two quaternions\n     *\n     * @param a - the first quaternion\n     * @param b - the second quaternion\n     * @param dst - quaternion to hold result. If not passed in a new one is created.\n     * @returns A quaternion that is the result of a * b\n     */\n    function multiply(a, b, dst) {\n      var newDst = dst != null ? dst : new Ctor(4);\n      var ax = a[0];\n      var ay = a[1];\n      var az = a[2];\n      var aw = a[3];\n      var bx = b[0];\n      var by = b[1];\n      var bz = b[2];\n      var bw = b[3];\n      newDst[0] = ax * bw + aw * bx + ay * bz - az * by;\n      newDst[1] = ay * bw + aw * by + az * bx - ax * bz;\n      newDst[2] = az * bw + aw * bz + ax * by - ay * bx;\n      newDst[3] = aw * bw - ax * bx - ay * by - az * bz;\n      return newDst;\n    }\n    /**\n     * Multiplies two quaternions\n     *\n     * @param a - the first quaternion\n     * @param b - the second quaternion\n     * @param dst - quaternion to hold result. If not passed in a new one is created.\n     * @returns A quaternion that is the result of a * b\n     */\n    var mul = multiply;\n    /**\n     * Rotates the given quaternion around the X axis by the given angle.\n     * @param q - quaternion to rotate\n     * @param angleInRadians - The angle by which to rotate\n     * @param dst - quaternion to hold result. If not passed in a new one is created.\n     * @returns A quaternion that is the result of a * b\n     */\n    function rotateX(q, angleInRadians, dst) {\n      var newDst = dst != null ? dst : new Ctor(4);\n      var halfAngle = angleInRadians * 0.5;\n      var qx = q[0];\n      var qy = q[1];\n      var qz = q[2];\n      var qw = q[3];\n      var bx = Math.sin(halfAngle);\n      var bw = Math.cos(halfAngle);\n      newDst[0] = qx * bw + qw * bx;\n      newDst[1] = qy * bw + qz * bx;\n      newDst[2] = qz * bw - qy * bx;\n      newDst[3] = qw * bw - qx * bx;\n      return newDst;\n    }\n    /**\n     * Rotates the given quaternion around the Y axis by the given angle.\n     * @param q - quaternion to rotate\n     * @param angleInRadians - The angle by which to rotate\n     * @param dst - quaternion to hold result. If not passed in a new one is created.\n     * @returns A quaternion that is the result of a * b\n     */\n    function rotateY(q, angleInRadians, dst) {\n      var newDst = dst != null ? dst : new Ctor(4);\n      var halfAngle = angleInRadians * 0.5;\n      var qx = q[0];\n      var qy = q[1];\n      var qz = q[2];\n      var qw = q[3];\n      var by = Math.sin(halfAngle);\n      var bw = Math.cos(halfAngle);\n      newDst[0] = qx * bw - qz * by;\n      newDst[1] = qy * bw + qw * by;\n      newDst[2] = qz * bw + qx * by;\n      newDst[3] = qw * bw - qy * by;\n      return newDst;\n    }\n    /**\n     * Rotates the given quaternion around the Z axis by the given angle.\n     * @param q - quaternion to rotate\n     * @param angleInRadians - The angle by which to rotate\n     * @param dst - quaternion to hold result. If not passed in a new one is created.\n     * @returns A quaternion that is the result of a * b\n     */\n    function rotateZ(q, angleInRadians, dst) {\n      var newDst = dst != null ? dst : new Ctor(4);\n      var halfAngle = angleInRadians * 0.5;\n      var qx = q[0];\n      var qy = q[1];\n      var qz = q[2];\n      var qw = q[3];\n      var bz = Math.sin(halfAngle);\n      var bw = Math.cos(halfAngle);\n      newDst[0] = qx * bw + qy * bz;\n      newDst[1] = qy * bw - qx * bz;\n      newDst[2] = qz * bw + qw * bz;\n      newDst[3] = qw * bw - qz * bz;\n      return newDst;\n    }\n    /**\n     * Spherically linear interpolate between two quaternions\n     *\n     * @param a - starting value\n     * @param b - ending value\n     * @param t - value where 0 = a and 1 = b\n     * @param dst - quaternion to hold result. If not passed in a new one is created.\n     * @returns A quaternion that is the result of a * b\n     */\n    function slerp(a, b, t, dst) {\n      var newDst = dst != null ? dst : new Ctor(4);\n      var ax = a[0];\n      var ay = a[1];\n      var az = a[2];\n      var aw = a[3];\n      var bx = b[0];\n      var by = b[1];\n      var bz = b[2];\n      var bw = b[3];\n      var cosOmega = ax * bx + ay * by + az * bz + aw * bw;\n      if (cosOmega < 0) {\n        cosOmega = -cosOmega;\n        bx = -bx;\n        by = -by;\n        bz = -bz;\n        bw = -bw;\n      }\n      var scale0;\n      var scale1;\n      if (1.0 - cosOmega > EPSILON) {\n        var omega = Math.acos(cosOmega);\n        var sinOmega = Math.sin(omega);\n        scale0 = Math.sin((1 - t) * omega) / sinOmega;\n        scale1 = Math.sin(t * omega) / sinOmega;\n      } else {\n        scale0 = 1.0 - t;\n        scale1 = t;\n      }\n      newDst[0] = scale0 * ax + scale1 * bx;\n      newDst[1] = scale0 * ay + scale1 * by;\n      newDst[2] = scale0 * az + scale1 * bz;\n      newDst[3] = scale0 * aw + scale1 * bw;\n      return newDst;\n    }\n    /**\n     * Compute the inverse of a quaternion\n     *\n     * @param q - quaternion to compute the inverse of\n     * @returns A quaternion that is the result of a * b\n     */\n    function inverse(q, dst) {\n      var newDst = dst != null ? dst : new Ctor(4);\n      var a0 = q[0];\n      var a1 = q[1];\n      var a2 = q[2];\n      var a3 = q[3];\n      var dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;\n      var invDot = dot ? 1 / dot : 0;\n      newDst[0] = -a0 * invDot;\n      newDst[1] = -a1 * invDot;\n      newDst[2] = -a2 * invDot;\n      newDst[3] = a3 * invDot;\n      return newDst;\n    }\n    /**\n     * Compute the conjugate of a quaternion\n     * For quaternions with a magnitude of 1 (a unit quaternion)\n     * this returns the same as the inverse but is faster to calculate.\n     *\n     * @param q - quaternion to compute the conjugate of.\n     * @param dst - quaternion to hold result. If not passed in a new one is created.\n     * @returns The conjugate of q\n     */\n    function conjugate(q, dst) {\n      var newDst = dst != null ? dst : new Ctor(4);\n      newDst[0] = -q[0];\n      newDst[1] = -q[1];\n      newDst[2] = -q[2];\n      newDst[3] = q[3];\n      return newDst;\n    }\n    /**\n     * Creates a quaternion from the given rotation matrix.\n     *\n     * The created quaternion is not normalized.\n     *\n     * @param m - rotation matrix\n     * @param dst - quaternion to hold result. If not passed in a new one is created.\n     * @returns the result\n     */\n    function fromMat(m, dst) {\n      var newDst = dst != null ? dst : new Ctor(4);\n      /*\n      0 1 2\n      3 4 5\n      6 7 8\n             0 1 2\n      4 5 6\n      8 9 10\n       */\n      // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes\n      // article \"Quaternion Calculus and Fast Animation\".\n      var trace = m[0] + m[5] + m[10];\n      if (trace > 0.0) {\n        // |w| > 1/2, may as well choose w > 1/2\n        var root = Math.sqrt(trace + 1); // 2w\n        newDst[3] = 0.5 * root;\n        var invRoot = 0.5 / root; // 1/(4w)\n        newDst[0] = (m[6] - m[9]) * invRoot;\n        newDst[1] = (m[8] - m[2]) * invRoot;\n        newDst[2] = (m[1] - m[4]) * invRoot;\n      } else {\n        // |w| <= 1/2\n        var i = 0;\n        if (m[5] > m[0]) {\n          i = 1;\n        }\n        if (m[10] > m[i * 4 + i]) {\n          i = 2;\n        }\n        var j = (i + 1) % 3;\n        var k = (i + 2) % 3;\n        var _root = Math.sqrt(m[i * 4 + i] - m[j * 4 + j] - m[k * 4 + k] + 1.0);\n        newDst[i] = 0.5 * _root;\n        var _invRoot = 0.5 / _root;\n        newDst[3] = (m[j * 4 + k] - m[k * 4 + j]) * _invRoot;\n        newDst[j] = (m[j * 4 + i] + m[i * 4 + j]) * _invRoot;\n        newDst[k] = (m[k * 4 + i] + m[i * 4 + k]) * _invRoot;\n      }\n      return newDst;\n    }\n    /**\n     * Creates a quaternion from the given euler angle x, y, z using the provided intrinsic order for the conversion.\n     *\n     * @param xAngleInRadians - angle to rotate around X axis in radians.\n     * @param yAngleInRadians - angle to rotate around Y axis in radians.\n     * @param zAngleInRadians - angle to rotate around Z axis in radians.\n     * @param order - order to apply euler angles\n     * @param dst - quaternion to hold result. If not passed in a new one is created.\n     * @returns A quaternion representing the same rotation as the euler angles applied in the given order\n     */\n    function fromEuler(xAngleInRadians, yAngleInRadians, zAngleInRadians, order, dst) {\n      var newDst = dst != null ? dst : new Ctor(4);\n      var xHalfAngle = xAngleInRadians * 0.5;\n      var yHalfAngle = yAngleInRadians * 0.5;\n      var zHalfAngle = zAngleInRadians * 0.5;\n      var sx = Math.sin(xHalfAngle);\n      var cx = Math.cos(xHalfAngle);\n      var sy = Math.sin(yHalfAngle);\n      var cy = Math.cos(yHalfAngle);\n      var sz = Math.sin(zHalfAngle);\n      var cz = Math.cos(zHalfAngle);\n      switch (order) {\n        case 'xyz':\n          newDst[0] = sx * cy * cz + cx * sy * sz;\n          newDst[1] = cx * sy * cz - sx * cy * sz;\n          newDst[2] = cx * cy * sz + sx * sy * cz;\n          newDst[3] = cx * cy * cz - sx * sy * sz;\n          break;\n        case 'xzy':\n          newDst[0] = sx * cy * cz - cx * sy * sz;\n          newDst[1] = cx * sy * cz - sx * cy * sz;\n          newDst[2] = cx * cy * sz + sx * sy * cz;\n          newDst[3] = cx * cy * cz + sx * sy * sz;\n          break;\n        case 'yxz':\n          newDst[0] = sx * cy * cz + cx * sy * sz;\n          newDst[1] = cx * sy * cz - sx * cy * sz;\n          newDst[2] = cx * cy * sz - sx * sy * cz;\n          newDst[3] = cx * cy * cz + sx * sy * sz;\n          break;\n        case 'yzx':\n          newDst[0] = sx * cy * cz + cx * sy * sz;\n          newDst[1] = cx * sy * cz + sx * cy * sz;\n          newDst[2] = cx * cy * sz - sx * sy * cz;\n          newDst[3] = cx * cy * cz - sx * sy * sz;\n          break;\n        case 'zxy':\n          newDst[0] = sx * cy * cz - cx * sy * sz;\n          newDst[1] = cx * sy * cz + sx * cy * sz;\n          newDst[2] = cx * cy * sz + sx * sy * cz;\n          newDst[3] = cx * cy * cz - sx * sy * sz;\n          break;\n        case 'zyx':\n          newDst[0] = sx * cy * cz - cx * sy * sz;\n          newDst[1] = cx * sy * cz + sx * cy * sz;\n          newDst[2] = cx * cy * sz - sx * sy * cz;\n          newDst[3] = cx * cy * cz + sx * sy * sz;\n          break;\n        default:\n          throw new Error(`Unknown rotation order: ${order}`);\n      }\n      return newDst;\n    }\n    /**\n     * Copies a quaternion. (same as {@link quat.clone})\n     * Also see {@link quat.create} and {@link quat.set}\n     * @param q - The quaternion.\n     * @param dst - quaternion to hold result. If not passed in a new one is created.\n     * @returns A quaternion that is a copy of q\n     */\n    function copy(q, dst) {\n      var newDst = dst != null ? dst : new Ctor(4);\n      newDst[0] = q[0];\n      newDst[1] = q[1];\n      newDst[2] = q[2];\n      newDst[3] = q[3];\n      return newDst;\n    }\n    /**\n     * Clones a quaternion. (same as {@link quat.copy})\n     * Also see {@link quat.create} and {@link quat.set}\n     * @param q - The quaternion.\n     * @param dst - quaternion to hold result. If not passed in a new one is created.\n     * @returns A copy of q.\n     */\n    var clone = copy;\n    /**\n     * Adds two quaternions; assumes a and b have the same dimension.\n     * @param a - Operand quaternion.\n     * @param b - Operand quaternion.\n     * @param dst - quaternion to hold result. If not passed in a new one is created.\n     * @returns A quaternion that is the sum of a and b.\n     */\n    function add(a, b, dst) {\n      var newDst = dst != null ? dst : new Ctor(4);\n      newDst[0] = a[0] + b[0];\n      newDst[1] = a[1] + b[1];\n      newDst[2] = a[2] + b[2];\n      newDst[3] = a[3] + b[3];\n      return newDst;\n    }\n    /**\n     * Subtracts two quaternions.\n     * @param a - Operand quaternion.\n     * @param b - Operand quaternion.\n     * @param dst - quaternion to hold result. If not passed in a new one is created.\n     * @returns A quaternion that is the difference of a and b.\n     */\n    function subtract(a, b, dst) {\n      var newDst = dst != null ? dst : new Ctor(4);\n      newDst[0] = a[0] - b[0];\n      newDst[1] = a[1] - b[1];\n      newDst[2] = a[2] - b[2];\n      newDst[3] = a[3] - b[3];\n      return newDst;\n    }\n    /**\n     * Subtracts two quaternions.\n     * @param a - Operand quaternion.\n     * @param b - Operand quaternion.\n     * @param dst - quaternion to hold result. If not passed in a new one is created.\n     * @returns A quaternion that is the difference of a and b.\n     */\n    var sub = subtract;\n    /**\n     * Multiplies a quaternion by a scalar.\n     * @param v - The quaternion.\n     * @param k - The scalar.\n     * @param dst - quaternion to hold result. If not passed in a new one is created.\n     * @returns The scaled quaternion.\n     */\n    function mulScalar(v, k, dst) {\n      var newDst = dst != null ? dst : new Ctor(4);\n      newDst[0] = v[0] * k;\n      newDst[1] = v[1] * k;\n      newDst[2] = v[2] * k;\n      newDst[3] = v[3] * k;\n      return newDst;\n    }\n    /**\n     * Multiplies a quaternion by a scalar. (same as mulScalar)\n     * @param v - The quaternion.\n     * @param k - The scalar.\n     * @param dst - quaternion to hold result. If not passed in a new one is created.\n     * @returns The scaled quaternion.\n     */\n    var scale = mulScalar;\n    /**\n     * Divides a vector by a scalar.\n     * @param v - The vector.\n     * @param k - The scalar.\n     * @param dst - quaternion to hold result. If not passed in a new one is created.\n     * @returns The scaled quaternion.\n     */\n    function divScalar(v, k, dst) {\n      var newDst = dst != null ? dst : new Ctor(4);\n      newDst[0] = v[0] / k;\n      newDst[1] = v[1] / k;\n      newDst[2] = v[2] / k;\n      newDst[3] = v[3] / k;\n      return newDst;\n    }\n    /**\n     * Computes the dot product of two quaternions\n     * @param a - Operand quaternion.\n     * @param b - Operand quaternion.\n     * @returns dot product\n     */\n    function dot(a, b) {\n      return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];\n    }\n    /**\n     * Performs linear interpolation on two quaternions.\n     * Given quaternions a and b and interpolation coefficient t, returns\n     * a + t * (b - a).\n     * @param a - Operand quaternion.\n     * @param b - Operand quaternion.\n     * @param t - Interpolation coefficient.\n     * @param dst - quaternion to hold result. If not passed in a new one is created.\n     * @returns The linear interpolated result.\n     */\n    function lerp(a, b, t, dst) {\n      var newDst = dst != null ? dst : new Ctor(4);\n      newDst[0] = a[0] + t * (b[0] - a[0]);\n      newDst[1] = a[1] + t * (b[1] - a[1]);\n      newDst[2] = a[2] + t * (b[2] - a[2]);\n      newDst[3] = a[3] + t * (b[3] - a[3]);\n      return newDst;\n    }\n    /**\n     * Computes the length of quaternion\n     * @param v - quaternion.\n     * @returns length of quaternion.\n     */\n    function length(v) {\n      var v0 = v[0];\n      var v1 = v[1];\n      var v2 = v[2];\n      var v3 = v[3];\n      return Math.sqrt(v0 * v0 + v1 * v1 + v2 * v2 + v3 * v3);\n    }\n    /**\n     * Computes the length of quaternion (same as length)\n     * @param v - quaternion.\n     * @returns length of quaternion.\n     */\n    var len = length;\n    /**\n     * Computes the square of the length of quaternion\n     * @param v - quaternion.\n     * @returns square of the length of quaternion.\n     */\n    function lengthSq(v) {\n      var v0 = v[0];\n      var v1 = v[1];\n      var v2 = v[2];\n      var v3 = v[3];\n      return v0 * v0 + v1 * v1 + v2 * v2 + v3 * v3;\n    }\n    /**\n     * Computes the square of the length of quaternion (same as lengthSq)\n     * @param v - quaternion.\n     * @returns square of the length of quaternion.\n     */\n    var lenSq = lengthSq;\n    /**\n     * Divides a quaternion by its Euclidean length and returns the quotient.\n     * @param v - The quaternion.\n     * @param dst - quaternion to hold result. If not passed in a new one is created.\n     * @returns The normalized quaternion.\n     */\n    function normalize(v, dst) {\n      var newDst = dst != null ? dst : new Ctor(4);\n      var v0 = v[0];\n      var v1 = v[1];\n      var v2 = v[2];\n      var v3 = v[3];\n      var len = Math.sqrt(v0 * v0 + v1 * v1 + v2 * v2 + v3 * v3);\n      if (len > 0.00001) {\n        newDst[0] = v0 / len;\n        newDst[1] = v1 / len;\n        newDst[2] = v2 / len;\n        newDst[3] = v3 / len;\n      } else {\n        newDst[0] = 0;\n        newDst[1] = 0;\n        newDst[2] = 0;\n        newDst[3] = 1;\n      }\n      return newDst;\n    }\n    /**\n     * Check if 2 quaternions are approximately equal\n     * @param a - Operand quaternion.\n     * @param b - Operand quaternion.\n     * @returns true if quaternions are approximately equal\n     */\n    function equalsApproximately(a, b) {\n      return Math.abs(a[0] - b[0]) < EPSILON && Math.abs(a[1] - b[1]) < EPSILON && Math.abs(a[2] - b[2]) < EPSILON && Math.abs(a[3] - b[3]) < EPSILON;\n    }\n    /**\n     * Check if 2 quaternions are exactly equal\n     * @param a - Operand quaternion.\n     * @param b - Operand quaternion.\n     * @returns true if quaternions are exactly equal\n     */\n    function equals(a, b) {\n      return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];\n    }\n    /**\n     * Creates an identity quaternion\n     * @param dst - quaternion to hold result. If not passed in a new one is created.\n     * @returns an identity quaternion\n     */\n    function identity(dst) {\n      var newDst = dst != null ? dst : new Ctor(4);\n      newDst[0] = 0;\n      newDst[1] = 0;\n      newDst[2] = 0;\n      newDst[3] = 1;\n      return newDst;\n    }\n    var tempVec3 = vec3.create();\n    var xUnitVec3 = vec3.create();\n    var yUnitVec3 = vec3.create();\n    /**\n     * Computes a quaternion to represent the shortest rotation from one vector to another.\n     *\n     * @param aUnit - the start vector\n     * @param bUnit - the end vector\n     * @param dst - quaternion to hold result. If not passed in a new one is created.\n     * @returns the result\n     */\n    function rotationTo(aUnit, bUnit, dst) {\n      var newDst = dst != null ? dst : new Ctor(4);\n      var dot = vec3.dot(aUnit, bUnit);\n      if (dot < -0.999999) {\n        vec3.cross(xUnitVec3, aUnit, tempVec3);\n        if (vec3.len(tempVec3) < 0.000001) {\n          vec3.cross(yUnitVec3, aUnit, tempVec3);\n        }\n        vec3.normalize(tempVec3, tempVec3);\n        fromAxisAngle(tempVec3, Math.PI, newDst);\n        return newDst;\n      } else if (dot > 0.999999) {\n        newDst[0] = 0;\n        newDst[1] = 0;\n        newDst[2] = 0;\n        newDst[3] = 1;\n        return newDst;\n      } else {\n        vec3.cross(aUnit, bUnit, tempVec3);\n        newDst[0] = tempVec3[0];\n        newDst[1] = tempVec3[1];\n        newDst[2] = tempVec3[2];\n        newDst[3] = 1 + dot;\n        return normalize(newDst, newDst);\n      }\n    }\n    var tempQuat1 = new Ctor(4);\n    var tempQuat2 = new Ctor(4);\n    /**\n     * Performs a spherical linear interpolation with two control points\n     *\n     * @param a - the first quaternion\n     * @param b - the second quaternion\n     * @param c - the third quaternion\n     * @param d - the fourth quaternion\n     * @param t - Interpolation coefficient 0 to 1\n     * @returns result\n     */\n    function sqlerp(a, b, c, d, t, dst) {\n      var newDst = dst != null ? dst : new Ctor(4);\n      slerp(a, d, t, tempQuat1);\n      slerp(b, c, t, tempQuat2);\n      slerp(tempQuat1, tempQuat2, 2 * t * (1 - t), newDst);\n      return newDst;\n    }\n    return {\n      create: create,\n      fromValues: fromValues,\n      set: set,\n      fromAxisAngle: fromAxisAngle,\n      toAxisAngle: toAxisAngle,\n      angle: angle,\n      multiply: multiply,\n      mul: mul,\n      rotateX: rotateX,\n      rotateY: rotateY,\n      rotateZ: rotateZ,\n      slerp: slerp,\n      inverse: inverse,\n      conjugate: conjugate,\n      fromMat: fromMat,\n      fromEuler: fromEuler,\n      copy: copy,\n      clone: clone,\n      add: add,\n      subtract: subtract,\n      sub: sub,\n      mulScalar: mulScalar,\n      scale: scale,\n      divScalar: divScalar,\n      dot: dot,\n      lerp: lerp,\n      length: length,\n      len: len,\n      lengthSq: lengthSq,\n      lenSq: lenSq,\n      normalize: normalize,\n      equalsApproximately: equalsApproximately,\n      equals: equals,\n      identity: identity,\n      rotationTo: rotationTo,\n      sqlerp: sqlerp\n    };\n  }\n  var cache$1 = new Map();\n  /**\n   *\n   * Quat4 math functions.\n   *\n   * Almost all functions take an optional `newDst` argument. If it is not passed in the\n   * functions will create a new `Quat4`. In other words you can do this\n   *\n   *     const v = quat4.cross(v1, v2);  // Creates a new Quat4 with the cross product of v1 x v2.\n   *\n   * or\n   *\n   *     const v = quat4.create();\n   *     quat4.cross(v1, v2, v);  // Puts the cross product of v1 x v2 in v\n   *\n   * The first style is often easier but depending on where it's used it generates garbage where\n   * as there is almost never allocation with the second style.\n   *\n   * It is always safe to pass any vector as the destination. So for example\n   *\n   *     quat4.cross(v1, v2, v1);  // Puts the cross product of v1 x v2 in v1\n   *\n   */\n  function getAPI$1(Ctor) {\n    var api = cache$1.get(Ctor);\n    if (!api) {\n      api = getAPIImpl$1(Ctor);\n      cache$1.set(Ctor, api);\n    }\n    return api;\n  }\n\n  /*\n   * Copyright 2022 Gregg Tavares\n   *\n   * Permission is hereby granted, free of charge, to any person obtaining a\n   * copy of this software and associated documentation files (the \"Software\"),\n   * to deal in the Software without restriction, including without limitation\n   * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n   * and/or sell copies of the Software, and to permit persons to whom the\n   * Software is furnished to do so, subject to the following conditions:\n   *\n   * The above copyright notice and this permission notice shall be included in\n   * all copies or substantial portions of the Software.\n   *\n   * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n   * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n   * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n   * DEALINGS IN THE SOFTWARE.\n   */\n  /**\n   * Generates am typed API for Vec4\n   * */\n  function getAPIImpl(Ctor) {\n    /**\n     * Creates a vec4; may be called with x, y, z to set initial values.\n     * @param x - Initial x value.\n     * @param y - Initial y value.\n     * @param z - Initial z value.\n     * @param w - Initial w value.\n     * @returns the created vector\n     */\n    function create(x, y, z, w) {\n      var newDst = new Ctor(4);\n      if (x !== undefined) {\n        newDst[0] = x;\n        if (y !== undefined) {\n          newDst[1] = y;\n          if (z !== undefined) {\n            newDst[2] = z;\n            if (w !== undefined) {\n              newDst[3] = w;\n            }\n          }\n        }\n      }\n      return newDst;\n    }\n    /**\n     * Creates a vec4; may be called with x, y, z to set initial values. (same as create)\n     * @param x - Initial x value.\n     * @param y - Initial y value.\n     * @param z - Initial z value.\n     * @param z - Initial w value.\n     * @returns the created vector\n     */\n    var fromValues = create;\n    /**\n     * Sets the values of a Vec4\n     * Also see {@link vec4.create} and {@link vec4.copy}\n     *\n     * @param x first value\n     * @param y second value\n     * @param z third value\n     * @param w fourth value\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A vector with its elements set.\n     */\n    function set(x, y, z, w, dst) {\n      var newDst = dst != null ? dst : new Ctor(4);\n      newDst[0] = x;\n      newDst[1] = y;\n      newDst[2] = z;\n      newDst[3] = w;\n      return newDst;\n    }\n    /**\n     * Applies Math.ceil to each element of vector\n     * @param v - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A vector that is the ceil of each element of v.\n     */\n    function ceil(v, dst) {\n      var newDst = dst != null ? dst : new Ctor(4);\n      newDst[0] = Math.ceil(v[0]);\n      newDst[1] = Math.ceil(v[1]);\n      newDst[2] = Math.ceil(v[2]);\n      newDst[3] = Math.ceil(v[3]);\n      return newDst;\n    }\n    /**\n     * Applies Math.floor to each element of vector\n     * @param v - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A vector that is the floor of each element of v.\n     */\n    function floor(v, dst) {\n      var newDst = dst != null ? dst : new Ctor(4);\n      newDst[0] = Math.floor(v[0]);\n      newDst[1] = Math.floor(v[1]);\n      newDst[2] = Math.floor(v[2]);\n      newDst[3] = Math.floor(v[3]);\n      return newDst;\n    }\n    /**\n     * Applies Math.round to each element of vector\n     * @param v - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A vector that is the round of each element of v.\n     */\n    function round(v, dst) {\n      var newDst = dst != null ? dst : new Ctor(4);\n      newDst[0] = Math.round(v[0]);\n      newDst[1] = Math.round(v[1]);\n      newDst[2] = Math.round(v[2]);\n      newDst[3] = Math.round(v[3]);\n      return newDst;\n    }\n    /**\n     * Clamp each element of vector between min and max\n     * @param v - Operand vector.\n     * @param max - Min value, default 0\n     * @param min - Max value, default 1\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A vector that the clamped value of each element of v.\n     */\n    function clamp(v) {\n      var min = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var max = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n      var dst = arguments.length > 3 ? arguments[3] : undefined;\n      var newDst = dst != null ? dst : new Ctor(4);\n      newDst[0] = Math.min(max, Math.max(min, v[0]));\n      newDst[1] = Math.min(max, Math.max(min, v[1]));\n      newDst[2] = Math.min(max, Math.max(min, v[2]));\n      newDst[3] = Math.min(max, Math.max(min, v[3]));\n      return newDst;\n    }\n    /**\n     * Adds two vectors; assumes a and b have the same dimension.\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A vector that is the sum of a and b.\n     */\n    function add(a, b, dst) {\n      var newDst = dst != null ? dst : new Ctor(4);\n      newDst[0] = a[0] + b[0];\n      newDst[1] = a[1] + b[1];\n      newDst[2] = a[2] + b[2];\n      newDst[3] = a[3] + b[3];\n      return newDst;\n    }\n    /**\n     * Adds two vectors, scaling the 2nd; assumes a and b have the same dimension.\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param scale - Amount to scale b\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A vector that is the sum of a + b * scale.\n     */\n    function addScaled(a, b, scale, dst) {\n      var newDst = dst != null ? dst : new Ctor(4);\n      newDst[0] = a[0] + b[0] * scale;\n      newDst[1] = a[1] + b[1] * scale;\n      newDst[2] = a[2] + b[2] * scale;\n      newDst[3] = a[3] + b[3] * scale;\n      return newDst;\n    }\n    /**\n     * Subtracts two vectors.\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A vector that is the difference of a and b.\n     */\n    function subtract(a, b, dst) {\n      var newDst = dst != null ? dst : new Ctor(4);\n      newDst[0] = a[0] - b[0];\n      newDst[1] = a[1] - b[1];\n      newDst[2] = a[2] - b[2];\n      newDst[3] = a[3] - b[3];\n      return newDst;\n    }\n    /**\n     * Subtracts two vectors.\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A vector that is the difference of a and b.\n     */\n    var sub = subtract;\n    /**\n     * Check if 2 vectors are approximately equal\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @returns true if vectors are approximately equal\n     */\n    function equalsApproximately(a, b) {\n      return Math.abs(a[0] - b[0]) < EPSILON && Math.abs(a[1] - b[1]) < EPSILON && Math.abs(a[2] - b[2]) < EPSILON && Math.abs(a[3] - b[3]) < EPSILON;\n    }\n    /**\n     * Check if 2 vectors are exactly equal\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @returns true if vectors are exactly equal\n     */\n    function equals(a, b) {\n      return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];\n    }\n    /**\n     * Performs linear interpolation on two vectors.\n     * Given vectors a and b and interpolation coefficient t, returns\n     * a + t * (b - a).\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param t - Interpolation coefficient.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The linear interpolated result.\n     */\n    function lerp(a, b, t, dst) {\n      var newDst = dst != null ? dst : new Ctor(4);\n      newDst[0] = a[0] + t * (b[0] - a[0]);\n      newDst[1] = a[1] + t * (b[1] - a[1]);\n      newDst[2] = a[2] + t * (b[2] - a[2]);\n      newDst[3] = a[3] + t * (b[3] - a[3]);\n      return newDst;\n    }\n    /**\n     * Performs linear interpolation on two vectors.\n     * Given vectors a and b and interpolation coefficient vector t, returns\n     * a + t * (b - a).\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param t - Interpolation coefficients vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns the linear interpolated result.\n     */\n    function lerpV(a, b, t, dst) {\n      var newDst = dst != null ? dst : new Ctor(4);\n      newDst[0] = a[0] + t[0] * (b[0] - a[0]);\n      newDst[1] = a[1] + t[1] * (b[1] - a[1]);\n      newDst[2] = a[2] + t[2] * (b[2] - a[2]);\n      newDst[3] = a[3] + t[3] * (b[3] - a[3]);\n      return newDst;\n    }\n    /**\n     * Return max values of two vectors.\n     * Given vectors a and b returns\n     * [max(a[0], b[0]), max(a[1], b[1]), max(a[2], b[2])].\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The max components vector.\n     */\n    function max(a, b, dst) {\n      var newDst = dst != null ? dst : new Ctor(4);\n      newDst[0] = Math.max(a[0], b[0]);\n      newDst[1] = Math.max(a[1], b[1]);\n      newDst[2] = Math.max(a[2], b[2]);\n      newDst[3] = Math.max(a[3], b[3]);\n      return newDst;\n    }\n    /**\n     * Return min values of two vectors.\n     * Given vectors a and b returns\n     * [min(a[0], b[0]), min(a[1], b[1]), min(a[2], b[2])].\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The min components vector.\n     */\n    function min(a, b, dst) {\n      var newDst = dst != null ? dst : new Ctor(4);\n      newDst[0] = Math.min(a[0], b[0]);\n      newDst[1] = Math.min(a[1], b[1]);\n      newDst[2] = Math.min(a[2], b[2]);\n      newDst[3] = Math.min(a[3], b[3]);\n      return newDst;\n    }\n    /**\n     * Multiplies a vector by a scalar.\n     * @param v - The vector.\n     * @param k - The scalar.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The scaled vector.\n     */\n    function mulScalar(v, k, dst) {\n      var newDst = dst != null ? dst : new Ctor(4);\n      newDst[0] = v[0] * k;\n      newDst[1] = v[1] * k;\n      newDst[2] = v[2] * k;\n      newDst[3] = v[3] * k;\n      return newDst;\n    }\n    /**\n     * Multiplies a vector by a scalar. (same as mulScalar)\n     * @param v - The vector.\n     * @param k - The scalar.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The scaled vector.\n     */\n    var scale = mulScalar;\n    /**\n     * Divides a vector by a scalar.\n     * @param v - The vector.\n     * @param k - The scalar.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The scaled vector.\n     */\n    function divScalar(v, k, dst) {\n      var newDst = dst != null ? dst : new Ctor(4);\n      newDst[0] = v[0] / k;\n      newDst[1] = v[1] / k;\n      newDst[2] = v[2] / k;\n      newDst[3] = v[3] / k;\n      return newDst;\n    }\n    /**\n     * Inverse a vector.\n     * @param v - The vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The inverted vector.\n     */\n    function inverse(v, dst) {\n      var newDst = dst != null ? dst : new Ctor(4);\n      newDst[0] = 1 / v[0];\n      newDst[1] = 1 / v[1];\n      newDst[2] = 1 / v[2];\n      newDst[3] = 1 / v[3];\n      return newDst;\n    }\n    /**\n     * Invert a vector. (same as inverse)\n     * @param v - The vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The inverted vector.\n     */\n    var invert = inverse;\n    /**\n     * Computes the dot product of two vectors\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @returns dot product\n     */\n    function dot(a, b) {\n      return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];\n    }\n    /**\n     * Computes the length of vector\n     * @param v - vector.\n     * @returns length of vector.\n     */\n    function length(v) {\n      var v0 = v[0];\n      var v1 = v[1];\n      var v2 = v[2];\n      var v3 = v[3];\n      return Math.sqrt(v0 * v0 + v1 * v1 + v2 * v2 + v3 * v3);\n    }\n    /**\n     * Computes the length of vector (same as length)\n     * @param v - vector.\n     * @returns length of vector.\n     */\n    var len = length;\n    /**\n     * Computes the square of the length of vector\n     * @param v - vector.\n     * @returns square of the length of vector.\n     */\n    function lengthSq(v) {\n      var v0 = v[0];\n      var v1 = v[1];\n      var v2 = v[2];\n      var v3 = v[3];\n      return v0 * v0 + v1 * v1 + v2 * v2 + v3 * v3;\n    }\n    /**\n     * Computes the square of the length of vector (same as lengthSq)\n     * @param v - vector.\n     * @returns square of the length of vector.\n     */\n    var lenSq = lengthSq;\n    /**\n     * Computes the distance between 2 points\n     * @param a - vector.\n     * @param b - vector.\n     * @returns distance between a and b\n     */\n    function distance(a, b) {\n      var dx = a[0] - b[0];\n      var dy = a[1] - b[1];\n      var dz = a[2] - b[2];\n      var dw = a[3] - b[3];\n      return Math.sqrt(dx * dx + dy * dy + dz * dz + dw * dw);\n    }\n    /**\n     * Computes the distance between 2 points (same as distance)\n     * @param a - vector.\n     * @param b - vector.\n     * @returns distance between a and b\n     */\n    var dist = distance;\n    /**\n     * Computes the square of the distance between 2 points\n     * @param a - vector.\n     * @param b - vector.\n     * @returns square of the distance between a and b\n     */\n    function distanceSq(a, b) {\n      var dx = a[0] - b[0];\n      var dy = a[1] - b[1];\n      var dz = a[2] - b[2];\n      var dw = a[3] - b[3];\n      return dx * dx + dy * dy + dz * dz + dw * dw;\n    }\n    /**\n     * Computes the square of the distance between 2 points (same as distanceSq)\n     * @param a - vector.\n     * @param b - vector.\n     * @returns square of the distance between a and b\n     */\n    var distSq = distanceSq;\n    /**\n     * Divides a vector by its Euclidean length and returns the quotient.\n     * @param v - The vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The normalized vector.\n     */\n    function normalize(v, dst) {\n      var newDst = dst != null ? dst : new Ctor(4);\n      var v0 = v[0];\n      var v1 = v[1];\n      var v2 = v[2];\n      var v3 = v[3];\n      var len = Math.sqrt(v0 * v0 + v1 * v1 + v2 * v2 + v3 * v3);\n      if (len > 0.00001) {\n        newDst[0] = v0 / len;\n        newDst[1] = v1 / len;\n        newDst[2] = v2 / len;\n        newDst[3] = v3 / len;\n      } else {\n        newDst[0] = 0;\n        newDst[1] = 0;\n        newDst[2] = 0;\n        newDst[3] = 0;\n      }\n      return newDst;\n    }\n    /**\n     * Negates a vector.\n     * @param v - The vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns -v.\n     */\n    function negate(v, dst) {\n      var newDst = dst != null ? dst : new Ctor(4);\n      newDst[0] = -v[0];\n      newDst[1] = -v[1];\n      newDst[2] = -v[2];\n      newDst[3] = -v[3];\n      return newDst;\n    }\n    /**\n     * Copies a vector. (same as {@link vec4.clone})\n     * Also see {@link vec4.create} and {@link vec4.set}\n     * @param v - The vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A copy of v.\n     */\n    function copy(v, dst) {\n      var newDst = dst != null ? dst : new Ctor(4);\n      newDst[0] = v[0];\n      newDst[1] = v[1];\n      newDst[2] = v[2];\n      newDst[3] = v[3];\n      return newDst;\n    }\n    /**\n     * Clones a vector. (same as {@link vec4.copy})\n     * Also see {@link vec4.create} and {@link vec4.set}\n     * @param v - The vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A copy of v.\n     */\n    var clone = copy;\n    /**\n     * Multiplies a vector by another vector (component-wise); assumes a and\n     * b have the same length.\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The vector of products of entries of a and b.\n     */\n    function multiply(a, b, dst) {\n      var newDst = dst != null ? dst : new Ctor(4);\n      newDst[0] = a[0] * b[0];\n      newDst[1] = a[1] * b[1];\n      newDst[2] = a[2] * b[2];\n      newDst[3] = a[3] * b[3];\n      return newDst;\n    }\n    /**\n     * Multiplies a vector by another vector (component-wise); assumes a and\n     * b have the same length. (same as mul)\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The vector of products of entries of a and b.\n     */\n    var mul = multiply;\n    /**\n     * Divides a vector by another vector (component-wise); assumes a and\n     * b have the same length.\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The vector of quotients of entries of a and b.\n     */\n    function divide(a, b, dst) {\n      var newDst = dst != null ? dst : new Ctor(4);\n      newDst[0] = a[0] / b[0];\n      newDst[1] = a[1] / b[1];\n      newDst[2] = a[2] / b[2];\n      newDst[3] = a[3] / b[3];\n      return newDst;\n    }\n    /**\n     * Divides a vector by another vector (component-wise); assumes a and\n     * b have the same length. (same as divide)\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The vector of quotients of entries of a and b.\n     */\n    var div = divide;\n    /**\n     * Zero's a vector\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The zeroed vector.\n     */\n    function zero(dst) {\n      var newDst = dst != null ? dst : new Ctor(4);\n      newDst[0] = 0;\n      newDst[1] = 0;\n      newDst[2] = 0;\n      newDst[3] = 0;\n      return newDst;\n    }\n    /**\n     * transform vec4 by 4x4 matrix\n     * @param v - the vector\n     * @param m - The matrix.\n     * @param dst - optional vec4 to store result. If not passed a new one is created.\n     * @returns the transformed vector\n     */\n    function transformMat4(v, m, dst) {\n      var newDst = dst != null ? dst : new Ctor(4);\n      var x = v[0];\n      var y = v[1];\n      var z = v[2];\n      var w = v[3];\n      newDst[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;\n      newDst[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;\n      newDst[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;\n      newDst[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;\n      return newDst;\n    }\n    /**\n     * Treat a 4D vector as a direction and set it's length\n     *\n     * @param a The vec4 to lengthen\n     * @param len The length of the resulting vector\n     * @returns The lengthened vector\n     */\n    function setLength(a, len, dst) {\n      var newDst = dst != null ? dst : new Ctor(4);\n      normalize(a, newDst);\n      return mulScalar(newDst, len, newDst);\n    }\n    /**\n     * Ensure a vector is not longer than a max length\n     *\n     * @param a The vec4 to limit\n     * @param maxLen The longest length of the resulting vector\n     * @returns The vector, shortened to maxLen if it's too long\n     */\n    function truncate(a, maxLen, dst) {\n      var newDst = dst != null ? dst : new Ctor(4);\n      if (length(a) > maxLen) {\n        return setLength(a, maxLen, newDst);\n      }\n      return copy(a, newDst);\n    }\n    /**\n     * Return the vector exactly between 2 endpoint vectors\n     *\n     * @param a Endpoint 1\n     * @param b Endpoint 2\n     * @returns The vector exactly residing between endpoints 1 and 2\n     */\n    function midpoint(a, b, dst) {\n      var newDst = dst != null ? dst : new Ctor(4);\n      return lerp(a, b, 0.5, newDst);\n    }\n    return {\n      create: create,\n      fromValues: fromValues,\n      set: set,\n      ceil: ceil,\n      floor: floor,\n      round: round,\n      clamp: clamp,\n      add: add,\n      addScaled: addScaled,\n      subtract: subtract,\n      sub: sub,\n      equalsApproximately: equalsApproximately,\n      equals: equals,\n      lerp: lerp,\n      lerpV: lerpV,\n      max: max,\n      min: min,\n      mulScalar: mulScalar,\n      scale: scale,\n      divScalar: divScalar,\n      inverse: inverse,\n      invert: invert,\n      dot: dot,\n      length: length,\n      len: len,\n      lengthSq: lengthSq,\n      lenSq: lenSq,\n      distance: distance,\n      dist: dist,\n      distanceSq: distanceSq,\n      distSq: distSq,\n      normalize: normalize,\n      negate: negate,\n      copy: copy,\n      clone: clone,\n      multiply: multiply,\n      mul: mul,\n      divide: divide,\n      div: div,\n      zero: zero,\n      transformMat4: transformMat4,\n      setLength: setLength,\n      truncate: truncate,\n      midpoint: midpoint\n    };\n  }\n  var cache = new Map();\n  /**\n   *\n   * Vec4 math functions.\n   *\n   * Almost all functions take an optional `newDst` argument. If it is not passed in the\n   * functions will create a new `Vec4`. In other words you can do this\n   *\n   *     const v = vec4.cross(v1, v2);  // Creates a new Vec4 with the cross product of v1 x v2.\n   *\n   * or\n   *\n   *     const v = vec4.create();\n   *     vec4.cross(v1, v2, v);  // Puts the cross product of v1 x v2 in v\n   *\n   * The first style is often easier but depending on where it's used it generates garbage where\n   * as there is almost never allocation with the second style.\n   *\n   * It is always safe to pass any vector as the destination. So for example\n   *\n   *     vec4.cross(v1, v2, v1);  // Puts the cross product of v1 x v2 in v1\n   *\n   */\n  function getAPI(Ctor) {\n    var api = cache.get(Ctor);\n    if (!api) {\n      api = getAPIImpl(Ctor);\n      cache.set(Ctor, api);\n    }\n    return api;\n  }\n\n  /**\n   * Some docs\n   * @namespace wgpu-matrix\n   */\n  /**\n   * Generate wgpu-matrix API for type\n   */\n  function wgpuMatrixAPI(Mat3Ctor, Mat4Ctor, QuatCtor, Vec2Ctor, Vec3Ctor, Vec4Ctor) {\n    return {\n      /** @namespace mat3 */\n      mat3: getAPI$3(Mat3Ctor),\n      /** @namespace mat4 */\n      mat4: getAPI$2(Mat4Ctor),\n      /** @namespace quat */\n      quat: getAPI$1(QuatCtor),\n      /** @namespace vec2 */\n      vec2: getAPI$5(Vec2Ctor),\n      /** @namespace vec3 */\n      vec3: getAPI$4(Vec3Ctor),\n      /** @namespace vec4 */\n      vec4: getAPI(Vec4Ctor)\n    };\n  }\n  var _wgpuMatrixAPI = wgpuMatrixAPI(Float32Array, Float32Array, Float32Array, Float32Array, Float32Array, Float32Array),\n    mat3 = exports.mat3 = _wgpuMatrixAPI.mat3,\n    mat4 = exports.mat4 = _wgpuMatrixAPI.mat4,\n    quat = exports.quat = _wgpuMatrixAPI.quat,\n    vec2 = exports.vec2 = _wgpuMatrixAPI.vec2,\n    vec3 = exports.vec3 = _wgpuMatrixAPI.vec3,\n    vec4 = exports.vec4 = _wgpuMatrixAPI.vec4;\n  var _wgpuMatrixAPI2 = wgpuMatrixAPI(Float64Array, Float64Array, Float64Array, Float64Array, Float64Array, Float64Array),\n    mat3d = exports.mat3d = _wgpuMatrixAPI2.mat3,\n    mat4d = exports.mat4d = _wgpuMatrixAPI2.mat4,\n    quatd = exports.quatd = _wgpuMatrixAPI2.quat,\n    vec2d = exports.vec2d = _wgpuMatrixAPI2.vec2,\n    vec3d = exports.vec3d = _wgpuMatrixAPI2.vec3,\n    vec4d = exports.vec4d = _wgpuMatrixAPI2.vec4;\n  var _wgpuMatrixAPI3 = wgpuMatrixAPI(ZeroArray, Array, Array, Array, Array, Array),\n    mat3n = exports.mat3n = _wgpuMatrixAPI3.mat3,\n    mat4n = exports.mat4n = _wgpuMatrixAPI3.mat4,\n    quatn = exports.quatn = _wgpuMatrixAPI3.quat,\n    vec2n = exports.vec2n = _wgpuMatrixAPI3.vec2,\n    vec3n = exports.vec3n = _wgpuMatrixAPI3.vec3,\n    vec4n = exports.vec4n = _wgpuMatrixAPI3.vec4;\n},1,[2,3,7,8,10,11],\"../../node_modules/wgpu-matrix/dist/3.x/wgpu-matrix.module.js\");\n__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {\n  function _interopRequireDefault(e) {\n    return e && e.__esModule ? e : {\n      \"default\": e\n    };\n  }\n  module.exports = _interopRequireDefault, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n},2,[],\"../../node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {\n  function _defineProperties(e, r) {\n    for (var t = 0; t < r.length; t++) {\n      var o = r[t];\n      o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _$$_REQUIRE(_dependencyMap[0], \"./toPropertyKey.js\")(o.key), o);\n    }\n  }\n  function _createClass(e, r, t) {\n    return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", {\n      writable: !1\n    }), e;\n  }\n  module.exports = _createClass, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n},3,[4],\"../../node_modules/@babel/runtime/helpers/createClass.js\");\n__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {\n  function toPropertyKey(t) {\n    var i = _$$_REQUIRE(_dependencyMap[0], \"./toPrimitive.js\")(t, \"string\");\n    return \"symbol\" == _$$_REQUIRE(_dependencyMap[1], \"./typeof.js\")[\"default\"](i) ? i : i + \"\";\n  }\n  module.exports = toPropertyKey, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n},4,[5,6],\"../../node_modules/@babel/runtime/helpers/toPropertyKey.js\");\n__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {\n  function toPrimitive(t, r) {\n    if (\"object\" != _$$_REQUIRE(_dependencyMap[0], \"./typeof.js\")[\"default\"](t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n      var i = e.call(t, r || \"default\");\n      if (\"object\" != _$$_REQUIRE(_dependencyMap[0], \"./typeof.js\")[\"default\"](i)) return i;\n      throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n  }\n  module.exports = toPrimitive, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n},5,[6],\"../../node_modules/@babel/runtime/helpers/toPrimitive.js\");\n__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {\n  function _typeof(o) {\n    \"@babel/helpers - typeof\";\n\n    return module.exports = _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n      return typeof o;\n    } : function (o) {\n      return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports, _typeof(o);\n  }\n  module.exports = _typeof, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n},6,[],\"../../node_modules/@babel/runtime/helpers/typeof.js\");\n__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {\n  function _classCallCheck(a, n) {\n    if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\");\n  }\n  module.exports = _classCallCheck, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n},7,[],\"../../node_modules/@babel/runtime/helpers/classCallCheck.js\");\n__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {\n  function _possibleConstructorReturn(t, e) {\n    if (e && (\"object\" == _$$_REQUIRE(_dependencyMap[0], \"./typeof.js\")[\"default\"](e) || \"function\" == typeof e)) return e;\n    if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\");\n    return _$$_REQUIRE(_dependencyMap[1], \"./assertThisInitialized.js\")(t);\n  }\n  module.exports = _possibleConstructorReturn, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n},8,[6,9],\"../../node_modules/@babel/runtime/helpers/possibleConstructorReturn.js\");\n__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {\n  function _assertThisInitialized(e) {\n    if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    return e;\n  }\n  module.exports = _assertThisInitialized, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n},9,[],\"../../node_modules/@babel/runtime/helpers/assertThisInitialized.js\");\n__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {\n  function _getPrototypeOf(t) {\n    return module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {\n      return t.__proto__ || Object.getPrototypeOf(t);\n    }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports, _getPrototypeOf(t);\n  }\n  module.exports = _getPrototypeOf, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n},10,[],\"../../node_modules/@babel/runtime/helpers/getPrototypeOf.js\");\n__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {\n  function _inherits(t, e) {\n    if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\");\n    t.prototype = Object.create(e && e.prototype, {\n      constructor: {\n        value: t,\n        writable: !0,\n        configurable: !0\n      }\n    }), Object.defineProperty(t, \"prototype\", {\n      writable: !1\n    }), e && _$$_REQUIRE(_dependencyMap[0], \"./setPrototypeOf.js\")(t, e);\n  }\n  module.exports = _inherits, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n},11,[12],\"../../node_modules/@babel/runtime/helpers/inherits.js\");\n__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {\n  function _setPrototypeOf(t, e) {\n    return module.exports = _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {\n      return t.__proto__ = e, t;\n    }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports, _setPrototypeOf(t, e);\n  }\n  module.exports = _setPrototypeOf, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n},12,[],\"../../node_modules/@babel/runtime/helpers/setPrototypeOf.js\");\n__r(0);";
